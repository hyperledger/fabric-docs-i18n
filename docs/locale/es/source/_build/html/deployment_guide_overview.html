

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Deploying a production network &mdash; hyperledger-fabricdocs master documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Operations Guides" href="ops_guide.html" />
    <link rel="prev" title="Videos" href="videos.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          


          
            <a href="index.html" class="icon icon-home"> hyperledger-fabricdocs
          

          
          </a>

          
            
            
              <div class="version">
                master
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          

<br><img style="background-color: #fff; height: unset; width: unset;" alt="Hyperledger Fabric" src=_images/hyperledger_fabric_logo_color.png />
<br>
<a href="https://github.com/hyperledger/fabric"><img style="padding: 0px; margin: auto auto auto auto;" alt="GitHub" src="_static/images/github_button.png"/></a>
&nbsp;<a href="https://stackoverflow.com/questions/tagged/hyperledger-fabric"><img style="padding: 0px; margin: auto auto auto auto;" alt="StackOverflow" src="_static/images/stackoverflow_button.png"/></a>
&nbsp;<a href="https://chat.hyperledger.org"><img style="padding: 0px; margin: auto auto auto auto;" alt="Rocket Chat" src="_static/images/rocketchat_button.png"/></a>
&nbsp;<a href="https://www.youtube.com/playlist?list=PL0MZ85B_96CH7wvtrRzV7SvtRY0sI0DEg"><img style="padding: 0px; margin: auto auto auto auto;" alt="Youtube Channel" src="_static/images/youtube_button.png"/></a>

        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="whatsnew.html">What’s new in Hyperledger Fabric v2.x</a></li>
<li class="toctree-l1"><a class="reference internal" href="whatsnew.html#release-notes">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="key_concepts.html">Principais Conceitos</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="developapps/developing_applications.html">Developing Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorials.html">Tutorials</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Deploying a production network</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#step-one-decide-on-your-network-configuration">Step one: Decide on your network configuration</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-two-set-up-a-cluster-for-your-resources">Step two: Set up a cluster for your resources</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#managing-your-infrastructure">Managing your infrastructure</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#step-three-set-up-your-cas">Step three: Set up your CAs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-four-use-the-ca-to-create-identities-and-msps">Step four: Use the CA to create identities and MSPs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#step-five-deploy-nodes">Step five: Deploy nodes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#create-a-peer">Create a peer</a></li>
<li class="toctree-l3"><a class="reference internal" href="#create-an-ordering-node">Create an ordering node</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#next-steps">Next steps</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="ops_guide.html">Operations Guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="upgrade.html">Upgrading to the latest release</a></li>
<li class="toctree-l1"><a class="reference internal" href="command_ref.html">Commands Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="architecture.html">Architecture Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="Fabric-FAQ.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="CONTRIBUTING.html">Contributions Welcome!</a></li>
<li class="toctree-l1"><a class="reference internal" href="glossary.html">Glossary</a></li>
<li class="toctree-l1"><a class="reference internal" href="releases.html">Releases</a></li>
<li class="toctree-l1"><a class="reference internal" href="questions.html">Still Have Questions?</a></li>
<li class="toctree-l1"><a class="reference internal" href="status.html">Status</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">hyperledger-fabricdocs</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Deploying a production network</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/deployment_guide_overview.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="deploying-a-production-network">
<h1>Deploying a production network<a class="headerlink" href="#deploying-a-production-network" title="Permalink to this headline">¶</a></h1>
<p>This deployment guide is a high level overview of the proper sequence for setting up production Fabric network components, in addition to best practices and a few of the many considerations to keep in mind when deploying. Note that this topic will discuss “setting up the network” as a holistic process from the perspective of a single individual. More likely than not, real world production networks will not be set up by a single individual but as a collaborative effort directed by several individuals (a collection of banks each setting up their own components, for example) instead.</p>
<p>The process for deploying a Fabric network is complex and presumes an understanding of Public Key Infrastructure and managing distributed systems. If you are a smart contract or application developer, you should not need this level of expertise in deploying a production level Fabric network. However, you might need to be aware of how networks are deployed in order to develop effective smart contracts and applications.</p>
<p>If all you need is a development environment to test chaincode, smart contracts, and applications against, check out <a class="reference internal" href="test_network.html"><span class="doc">##### Generate certificates using cryptogen tool #########</span></a>. It includes two organizations, each owning one peer, and a single ordering service organization that owns a single ordering node. <strong>This test network is not meant to provide a blueprint for deploying production components, and should not be used as such, as it makes assumptions and decisions that production deployments will not make.</strong></p>
<p>The guide will give you an overview of the steps of setting up production components and a production network:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#dg-step-one-decide-on-your-network-configuration"><span class="std std-ref">Step one: Decide on your network configuration</span></a></p></li>
<li><p><a class="reference internal" href="#dg-step-two-set-up-a-cluster-for-your-resources"><span class="std std-ref">Step two: Set up a cluster for your resources</span></a></p></li>
<li><p><a class="reference internal" href="#dg-step-three-set-up-your-cas"><span class="std std-ref">Step three: Set up your CAs</span></a></p></li>
<li><p><a class="reference internal" href="#dg-step-four-use-the-ca-to-create-identities-and-msps"><span class="std std-ref">Step four: Use the CA to create identities and MSPs</span></a></p></li>
<li><dl class="simple">
<dt><a class="reference internal" href="#dg-step-five-deploy-nodes"><span class="std std-ref">Step five: Deploy nodes</span></a></dt><dd><ul>
<li><p><a class="reference internal" href="#dg-create-a-peer"><span class="std std-ref">Create a peer</span></a></p></li>
<li><p><a class="reference internal" href="#dg-create-an-ordering-node"><span class="std std-ref">Create an ordering node</span></a></p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="section" id="step-one-decide-on-your-network-configuration">
<span id="dg-step-one-decide-on-your-network-configuration"></span><h2>Step one: Decide on your network configuration<a class="headerlink" href="#step-one-decide-on-your-network-configuration" title="Permalink to this headline">¶</a></h2>
<p>The structure of a blockchain network must be dictated by the use case. These fundamental business decisions will vary according to your use case, but let’s consider a few scenarios.</p>
<p>In contrast to development environments or proofs of concept, security, resource management, and high availability become a priority when operating in production. How many nodes do you need to satisfy high availability, and in what data centers do you wish to deploy them in to satisfy both the needs of disaster recovery and data residency? How will you ensure that your private keys and roots of trust remain secure?</p>
<p>In addition to the above, here is a sampling of the decisions you will need to make before deploying components:</p>
<ul class="simple">
<li><p><strong>Certificate Authority configuration</strong>.
As part of the overall decisions you have to make about your peers (how many, how many on each channel, and so on) and about your ordering service (how many nodes, who will own them), you also have to decide on how the CAs for your organization will be deployed. Production networks should be using Transport Layer Security (TLS), which will require setting up a TLS CA and using it to generate TLS certficates. This TLS CA will need to be deployed before your enrollment CA. We’ll discuss this more in <a class="reference internal" href="#dg-step-three-set-up-your-cas"><span class="std std-ref">Step three: Set up your CAs</span></a>.</p></li>
<li><p><strong>Use Organizational Units or not?</strong>
Some organizations might find it necessary to establish Organizational Units to create a separation between certain identities and MSPs created by a single CA.</p></li>
<li><p><strong>Database type.</strong>
Some channels in a network might require all data to be modeled in a way <a class="reference internal" href="couchdb_as_state_database.html"><span class="doc">CouchDB as the State Database</span></a> can understand, while other networks, prioritizing speed, might decide that all peers will use LevelDB. Note that channels should not have peers that use both CouchDB and LevelDB on them, as the two database types model data slightly differently.</p></li>
<li><p><strong>Channels and private data.</strong>
Some networks might decide that <a class="reference internal" href="channels.html"><span class="doc">Channels</span></a> are the best way to ensure privacy and isolation for certain transactions. Others might decide that a single channel, along with <a class="reference internal" href="private-data/private-data.html"><span class="doc">&lt;no title&gt;</span></a>, better serves their need for privacy.</p></li>
<li><p><strong>Container orchestration.</strong>
Different users might also make different decisions about their container orchestration, creating separate containers for their peer process, logging for the peer, CouchDB, gRPC communications, and chaincode, while other users might decide to combine some of these processes.</p></li>
<li><p><strong>Chaincode deployment method.</strong>
Users now have the option to deploy their chaincode using either the built in build and run support, a customized build and run using the <a class="reference internal" href="cc_launcher.html"><span class="doc">fi</span></a>, or using an <a class="reference internal" href="cc_service.html"><span class="doc">}</span></a>.</p></li>
<li><p><strong>Using firewalls.</strong>
In a production deployment, components belonging to one organization might need access to components from other organizations, necessitating the use of firewalls and advanced networking configuration. For example, applications using the Fabric SDK require access to all endorsing peers from all organizations and the ordering services for all channels. Similarly, peers need access to the ordering service on the channels that they are receiving new blocks from.</p></li>
</ul>
<p>However and wherever your components are deployed, you will need a high degree of expertise in your management system of choice (such as Kubernetes) in order to efficiently operate your network. Similarly, the structure of the network must be designed to fit the business use case and any relevant laws and regulations government of the industry in which the network will be designed to function.</p>
<p>This deployment guide will not go through every iteration and potential network configuration, but does give common guidelines and rules to consider.</p>
</div>
<div class="section" id="step-two-set-up-a-cluster-for-your-resources">
<span id="dg-step-two-set-up-a-cluster-for-your-resources"></span><h2>Step two: Set up a cluster for your resources<a class="headerlink" href="#step-two-set-up-a-cluster-for-your-resources" title="Permalink to this headline">¶</a></h2>
<p>Generally speaking, Fabric is agnostic to the method used to deploy and manage it. It is possible, for example, to deploy and manage a peer from a laptop. For a number of reasons, this is likely to be unadvisable, but there is nothing in Fabric that prohibits it.</p>
<p>As long as you have the ability to deploy containers, whether locally (or behind a firewall), or in a cloud, it should be possible to stand up components and connect them to each other. However, Kubernetes features a number of helpful tools that have made it a popular container management platform for deploying and managing Fabric networks. For more information about Kubernetes, check out <a class="reference external" href="https://kubernetes.io/docs">the Kubernetes documentation</a>. This topic will mostly limit its scope to the binaries and provide instructions that can be applied when using a Docker deployment or Kubernetes.</p>
<p>However and wherever you choose to deploy your components, you will need to make sure you have enough resources for the components to run effectively. The sizes you need will largely depend on your use case. If you plan to join a single peer to several high volume channels, it will need much more CPU and memory than a peer a user plans to join to a single channel. As a rough estimate, plan to dedicate approximately three times the resources to a peer as you plan to allocate to a single ordering node (as you will see below, it is recommended to deploy at least three and optimally five nodes in an ordering service). Similarly, you should need approximately a tenth of the resources for a CA as you will for a peer. You will also need to add storage to your cluster (some cloud providers may provide storage) as you cannot configure Persistent Volumes and Persistent Volume Claims without storage being set up with your cloud provider first.</p>
<p>By deploying a proof of concept network and testing it under load, you will have a better sense of the resources you will require.</p>
<div class="section" id="managing-your-infrastructure">
<h3>Managing your infrastructure<a class="headerlink" href="#managing-your-infrastructure" title="Permalink to this headline">¶</a></h3>
<p>The exact methods and tools you use to manage your backend will depend on the backend you choose. However, here are some considerations worth noting.</p>
<ul class="simple">
<li><p>Using secret objects to securely store important configuration files in your cluster. For information about Kubernetes secrets, check out <a class="reference external" href="https://kubernetes.io/docs/concepts/configuration/secret/">Kubernetes secrets</a>. You also have the option to use Hardened Security Modules (HSMs) or encrypted Persistent Volumes (PVs). Along similar lines, after deploying Fabric components, you will likely want to connect to a container on your own backend, for example using a private repo in a service like Docker Hub. In that case, you will need to code the login information in the form of a Kubernetes secret and include it in the YAML file when deploying components.</p></li>
<li><p>Cluster considerations and node sizing. In step 2 above, we discussed a general outline for how to think about the sizings of nodes. Your use case, as well as a robust period of development, is the only way you will truly know how how large your peers, ordering nodes, and CAs will need to be.</p></li>
<li><p>How you choose to mount your volumes. It is a best practice to mount the volumes relevant to your nodes external to the place where your nodes are deployed. This will allow you to reference these volumes later on (for example, restarting a node or a container that has crashed) without having to redeploy or regenerate your crypto material.</p></li>
<li><p>How you will monitor your resources. It is critical that you establish a strategy and method for monitoring the resources used by your individual nodes and the resources deployed to your cluster generally. As you join your peers to more channels, you will need likely need to increase its CPU and memory allocation. Similarly, you will need to make sure you have enough storage space for your state database and blockchain.</p></li>
</ul>
</div>
</div>
<div class="section" id="step-three-set-up-your-cas">
<span id="dg-step-three-set-up-your-cas"></span><h2>Step three: Set up your CAs<a class="headerlink" href="#step-three-set-up-your-cas" title="Permalink to this headline">¶</a></h2>
<p>The first component that must be deployed in a Fabric network is a CA. This is because the certificates associated with a node (not just for the node itself but also the certificates identifying who can administer the node) must be created before the node itself can be deployed. While it is not necessary to use the Fabric CA to create these certificates, the Fabric CA also creates MSP structures that are needed for components and organizations to be properly defined. If a user chooses to use a CA other than the Fabric CA, they will have to create the MSP folders themselves.</p>
<ul class="simple">
<li><p>One CA (or more, if you are using intermediate CAs — more on intermediate CAs below) is used to generate (through a process called “enrollment”) the certificates of the admin of an organization, the MSP of that organization, and any nodes owned by that organization. This CA will also generate the certificates for any additional users. Because of its role in “enrolling” identities, this CA is sometimes called the “enrollment CA” or the “ecert CA”.</p></li>
<li><p>The other CA generates the certificates used to secure communications on Transport Layer Security (TLS). For this reason, this CA is often referred to as a “TLS CA”. These TLS certificates are attached to actions as a way of preventing “man in the middle” attacks. Note that the TLS CA is only used for issuing certificates for nodes and can be shut down when that activity is completed. Users have the option to use one way (client only) TLS as well as two way (server and client) TLS, with the latter also known as “mutual TLS”. Because specifying that your network will be using TLS (which is recommended) should be decided before deploying the “enrollment” CA (the YAML file specifying the configuration of this CA has a field for enabling TLS), you should deploy your TLS CA first and use its root certificate when bootstrapping your enrollment CA. This TLS certificate will also be used by the <code class="docutils literal notranslate"><span class="pre">fabric-ca</span> <span class="pre">client</span></code> when connecting to the enrollment CA to enroll identities for users and nodes.</p></li>
</ul>
<p>While all of the non-TLS certificates associated with an organization can be created by a single “root” CA (that is, a CA that is its own root of trust), for added security organizations can decide to use “intermediate” CAs whose certificates are created by a root CA (or another intermediate CA that eventually leads back to a root CA). Because a compromise in the root CA leads to a collapse for its entire trust domain (the certs for the admins, nodes, and any CAs it has generated certificates for), intermediate CAs are a useful way to limit the exposure of the root CA. Whether you choose to use intermediate CAs will depend on the needs of your use case. They are not mandatory. Note that it is also possible to configure a Lightweight Directory Access Protocol (LDAP) to manage identities on a Fabric network for those enterprises that already have this implementation and do not want to add a layer of identity management to their existing infrastructure. The LDAP effectively pre registers all of the members of the directory and allows them to enroll based on the criteria given.</p>
<p><strong>In a production network, it is recommended to deploy at least one CA per organization for enrollment purposes and another for TLS.</strong> For example, if you deploy three peers that are associated with one organization and an ordering node that is associated with an ordering organization, you will need at least four CAs. Two of the CAs will be for the peer organization (generating the enrollment and TLS certificates for the peer, admins, communications, and the folder structure of the MSP representing the organization) and the other two will be for the orderer organization. Note that users will generally only register and enroll with the enrollment CA, while nodes will register and enroll with both the enrollment CA (where the node will get its signing certificates that identify it when it attempts to sign its actions) and with the TLS CA (where it will get the TLS certificates it uses to authenticate its communications).</p>
<p>To install the Fabric CA client, which is used to register and enroll identities, follow the instructions in <a class="reference external" href="https://hyperledger-fabric-ca.readthedocs.io/en/latest/users-guide.html#overview">the Fabric CA User’s Guide</a>. Note that there are a number of configuration options when deploying a CA (the database type, for example, or whether to use LDAP).</p>
<p>For an example of how to setup a CA and enroll its admin, check out <a class="reference external" href="https://hyperledger-fabric-ca.readthedocs.io/en/latest/operations_guide.html#setup-orderer-org-ca">Setup Orderer Org CA</a>. For an example of how to set up a TLS CA, check out <a class="reference external" href="https://hyperledger-fabric-ca.readthedocs.io/en/latest/operations_guide.html#setup-tls-ca">Setup TLS CA</a>. Note that bootstrapping the CA server means assigning a username and password that functions as “registering” the CA admin.</p>
</div>
<div class="section" id="step-four-use-the-ca-to-create-identities-and-msps">
<span id="dg-step-four-use-the-ca-to-create-identities-and-msps"></span><h2>Step four: Use the CA to create identities and MSPs<a class="headerlink" href="#step-four-use-the-ca-to-create-identities-and-msps" title="Permalink to this headline">¶</a></h2>
<p>After you have created your CAs, you can use them to create the certificates for the identities and components related to your organization (which is represented by an MSP). For each organization, you will need to, at a minimum:</p>
<ul class="simple">
<li><p><strong>Register and enroll an admin identity and create an MSP</strong>. After the CA that will be associated with an organization has been created, it can be used to first register an identity and then enroll it. In the first step, a username and password for the identity is assigned by the admin of the CA. Attributes and affiliations can also be given to the identity (for example, a <code class="docutils literal notranslate"><span class="pre">role</span></code> of <code class="docutils literal notranslate"><span class="pre">admin</span></code>, which is necessary for organization admins). After the identity has been registered, it can be enrolled by using the username and password. The CA will generate two certificates for this identity — a public certificate (also known as a signcert) known to the other members of the network, and the private key (stored in the <code class="docutils literal notranslate"><span class="pre">keystore</span></code> folder) used to sign actions taken by the identity. The CA will also generate an MSP file containing the public certificate of the CA issuing the certificate and the root of trust for the CA (this may or may not be the same CA). This MSP can be thought of as defining the organization associated with the identity of the admin. For an example of how this process looks, check out the <a class="reference external" href="https://hyperledger-fabric-ca.readthedocs.io/en/latest/operations_guide.html#enroll-org1-s-admin">this example of how an admin is enrolled</a>. In cases where the admin of the org will also be an admin of a node (which will be typical), <strong>you must create the org admin identity before creating the local MSP of a node, since the certificate of the node admin must be used when creating the local MSP</strong>.</p></li>
<li><p><strong>Register and enroll node identities</strong>. Just as an org admin identity is registered and enrolled, the identity of a node must be registered and enrolled with both an enrollment CA and the TLS CA. For this reason, it can be useful for your enrollment CA and TLS to share a database (which allows the node identity to only be registered once and enrolled by each CA server separately), though this is an optional configuration option. Instead of giving a node a role of <code class="docutils literal notranslate"><span class="pre">admin</span></code> or <code class="docutils literal notranslate"><span class="pre">user</span></code> when registering it with the enrollment CA, give it a role of <code class="docutils literal notranslate"><span class="pre">peer</span></code> or <code class="docutils literal notranslate"><span class="pre">orderer</span></code>. As with the admin, attributes and affiliations for this identity can also be assigned. The MSP structure for a node is known as a “local MSP”, since the permissions assigned to the identities are only relevant at the local (node) level. This MSP is created when the node identity is created, and is used when bootstrapping the node. You will use the TLS root certificate generated when enrolling with the TLS CA when joining your organization to the channel (this certificate must be added to the org MSP that was created when you enrolled your admin) and when using the peer binary as a CLI client to make calls to other peers (as in <code class="docutils literal notranslate"><span class="pre">peer</span> <span class="pre">chaincode</span> <span class="pre">invoke</span></code>) or ordering nodes (as in <code class="docutils literal notranslate"><span class="pre">peer</span> <span class="pre">channel</span> <span class="pre">fetch</span></code>) because there is no <code class="docutils literal notranslate"><span class="pre">orderer</span></code> CLI. It is not necessary to add the TLS root certificates to the local MSP of a node because these certificates are contained in the channel configuration.</p></li>
</ul>
<p>For more conceptual information about identities and permissions in a Fabric-based blockchain network, see <a class="reference internal" href="identity/identity.html"><span class="doc">&lt;no title&gt;</span></a> and <span class="xref std std-doc">membership/membership.html</span>.</p>
<p>For a look at how to use a CA to generate an admin identity and MSP, check out <a class="reference external" href="https://hyperledger-fabric-ca.readthedocs.io/en/latest/operations_guide.html#enroll-org1-s-admin">Enroll Org1’s Admin</a>.</p>
<p>To see how to use the enrollment CA to and the TLS CA to generate the certificates for a node, check out <a class="reference external" href="https://hyperledger-fabric-ca.readthedocs.io/en/latest/operations_guide.html#setup-org1-s-peers">Setup Org1’s Peers</a>.</p>
</div>
<div class="section" id="step-five-deploy-nodes">
<span id="dg-step-five-deploy-nodes"></span><h2>Step five: Deploy nodes<a class="headerlink" href="#step-five-deploy-nodes" title="Permalink to this headline">¶</a></h2>
<p>Once you have gathered all of the certificates and MSPs you need, you’re almost ready to create a node. As discussed above, there are a number of valid ways to deploy nodes.</p>
<div class="section" id="create-a-peer">
<span id="dg-create-a-peer"></span><h3>Create a peer<a class="headerlink" href="#create-a-peer" title="Permalink to this headline">¶</a></h3>
<p>Before you can create a peer, you will need to customize the configuration file for the peer. In Fabric, this file is called <code class="docutils literal notranslate"><span class="pre">core.yaml</span></code>. You can find a sample <code class="docutils literal notranslate"><span class="pre">core.yaml</span></code> configuration file <a class="reference external" href="https://github.com/hyperledger/fabric/blob/master/sampleconfig/core.yaml">in the sampleconfig directory of Hyperledger Fabric</a>.</p>
<p>As you can see in the file, there are quite a number of parameters you either have the option to set or will need to set for your node to work properly. In general, if you do not have the need to change a tuning value, leave it alone. You will, however, likely need to adjust the various addresses, specify the database type you want to use, as well as to specify where the MSP for the node is located.</p>
<p>You have two main options for tuning your configuration.</p>
<ol class="arabic simple">
<li><p>Edit the YAML file bundled with the binaries.</p></li>
<li><p>Use environment variable overrides when deploying.</p></li>
<li><p>Specify flags on CLI commands.</p></li>
</ol>
<p>Option 1 has the advantage of persisting your changes whenever you bring down and bring back up the node. The downside is that you will have to port the options you customized to the new YAML when upgrading to a new binary version (you should use the latest YAML when upgrading to a new version).</p>
<p>Either way, here are some values in <code class="docutils literal notranslate"><span class="pre">core.yaml</span></code> you must review.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">peer.localMspID</span></code>: this is the name of the local MSP of your peer organization. This MSP is where your peer organization admins will be listed as well as the peer organization’s root CA and TLS CA certificates.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">peer.mspConfigPath</span></code>: the place where the local MSP for the peer is located. Note that it is a best practice to mount this volume external to your container. This ensures that even if the container is stopped (for example, during a maintenance cycle) that the MSPs are not lost and have to be recreated.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">peer.address</span></code>: represents the endpoint to other peers in the same organization, an important consideration when establishing gossip communication within an organization.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">peer.tls</span></code>: When you set the <code class="docutils literal notranslate"><span class="pre">enabled</span></code> value to <code class="docutils literal notranslate"><span class="pre">true</span></code> (as should be done in a production network), you will have to specify the locations of the relevant TLS certificates. Note that all of the nodes in a network (both the peers and the ordering nodes) must either all have TLS enabled or not enabled. For production networks, it is highly recommended to enable TLS. As with your MSP, it is a best practice to mount this volume external to your container.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ledger</span></code>: users have a number of decisions to make about their ledger, including the state database type (LevelDB or CouchDB, for example), and its location (specified in <code class="docutils literal notranslate"><span class="pre">fileSystemPath</span></code>). Note that for CouchDB in particular it is a best practice to operate your state database external to the peer, as you will be better able to allocate specific resources to the database this way.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">gossip</span></code>: there are a number of configuration options to think about when setting up <a class="reference internal" href="gossip.html"><span class="doc">Gossip data dissemination protocol</span></a>, including the <code class="docutils literal notranslate"><span class="pre">externalEndpoint</span></code> (which makes peers discoverable to peers owned by other organizations) as well as the <code class="docutils literal notranslate"><span class="pre">bootstrap</span></code> address (which identifies a peer in the peer’s own organization).</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">chaincode.externalBuilders</span></code>: this field is important to set when using <span class="xref std std-doc">cc_service.html</span>.</p></li>
</ul>
<p>When you’re comfortable with how your peer has been configured, how your volumes are mounted, and your backend configuration, you can run the command to launch the peer (this command will depend on your backend configuration).</p>
</div>
<div class="section" id="create-an-ordering-node">
<span id="dg-create-an-ordering-node"></span><h3>Create an ordering node<a class="headerlink" href="#create-an-ordering-node" title="Permalink to this headline">¶</a></h3>
<p>Unlike the creation of a peer, you will need to create a genesis block (or reference a block that has already been created, if adding an ordering node to an existing ordering service) and specify the path to it before launching the ordering node.</p>
<p>In Fabric, this configuration file for ordering nodes is called <code class="docutils literal notranslate"><span class="pre">orderer.yaml</span></code>. You can find a sample <code class="docutils literal notranslate"><span class="pre">orderer.yaml</span></code> configuration file <a class="reference external" href="https://github.com/hyperledger/fabric/blob/master/sampleconfig/orderer.yaml">in the sampleconfig directory of Hyperledger Fabric</a>. Note that <code class="docutils literal notranslate"><span class="pre">orderer.yaml</span></code> is different than the “genesis block” of an ordering service. This block, which includes the initial configuration of the orderer system channel, must be created before an ordering node is created because it is used to bootstrap the node.</p>
<p>As with the peer, you will see that there are quite a number of parameters you either have the option to set or will need to set for your node to work properly. In general, if you do not have the need to change a tuning value, leave it alone.</p>
<p>You have two main options for tuning your configuration.</p>
<ol class="arabic simple">
<li><p>Edit the YAML file bundled with the binaries.</p></li>
<li><p>Use environment variable overrides when deploying.</p></li>
<li><p>Specify flags on CLI commands.</p></li>
</ol>
<p>Option 1 has the advantage of persisting your changes whenever you bring down and bring back up the node. The downside is that you will have to port the options you customized to the new YAML when upgrading to a new binary version (you should use the latest YAML when upgrading to a new version).</p>
<p>Either way, here are some values in <code class="docutils literal notranslate"><span class="pre">orderer.yaml</span></code> you must review. You will notice that some of these fields are the same as those in <code class="docutils literal notranslate"><span class="pre">core.yaml</span></code> only with different names.</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">General.LocalMSPID</span></code>: this is the name of the local MSP, generated by your CA, of your orderer organization.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">General.LocalMSPDir</span></code>: the place where the local MSP for the ordering node is located. Note that it is a best practice to mount this volume external to your container.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">General.ListenAddress</span></code> and <code class="docutils literal notranslate"><span class="pre">General.ListenPort</span></code>: represents the endpoint to other ordering nodes in the same organization.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">FileLedger</span></code>: although ordering nodes do not have a state database, they still all carry copies of the blockchain, as this allows them to verify permissions using the latest config block. Therefore the ledger fields should be customized with the correct file path.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Cluster</span></code>: these values are important for ordering service nodes that communicate with other ordering nodes, such as in a Raft based ordering service.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">General.BootstrapFile</span></code>: this is the name of the configuration block used to bootstrap an ordering node. If this node is the first node generated in an ordering service, this file will have to be generated and is known as the “genesis block”.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">General.BootstrapMethod</span></code>: the method by which the bootstrap block is given. For now, this can only be <code class="docutils literal notranslate"><span class="pre">file</span></code>, in which the file in the <code class="docutils literal notranslate"><span class="pre">BootstrapFile</span></code> is specified. Starting in 2.0, you can specify <code class="docutils literal notranslate"><span class="pre">none</span></code> to simply start the orderer without bootstrapping.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">Consensus</span></code>: determines the key/value pairs allowed by the consensus plugin (Raft ordering services are supported and recommended) for the Write Ahead Logs (<code class="docutils literal notranslate"><span class="pre">WALDir</span></code>) and Snapshots (<code class="docutils literal notranslate"><span class="pre">SnapDir</span></code>).</p></li>
</ul>
<p>When you’re comfortable with how your ordering node has been configured, how your volumes are mounted, and your backend configuration, you can run the command to launch the ordering node (this command will depend on your backend configuration).</p>
</div>
</div>
<div class="section" id="next-steps">
<h2>Next steps<a class="headerlink" href="#next-steps" title="Permalink to this headline">¶</a></h2>
<p>Blockchain networks are all about connection, so once you’ve deployed nodes, you’ll obviously want to connect them to other nodes! If you have a peer organization and a peer, you’ll want to join your organization to a consortium and join or <a class="reference internal" href="channels.html"><span class="doc">Channels</span></a>. If you have an ordering node, you will want to add peer organizations to your consortium. You’ll also want to learn how to develop chaincode, which you can learn about in the topics <a class="reference internal" href="developapps/scenario.html"><span class="doc">&lt;no title&gt;</span></a> and <a class="reference internal" href="chaincode_lifecycle.html"><span class="doc">&lt;no title&gt;</span></a>.</p>
<p>Part of the process of connecting nodes and creating channels will involve modifying policies to fit the use cases of business networks. For more information about policies, check out <a class="reference internal" href="policies/policies.html"><span class="doc">```</span></a>.</p>
<p>One of the common tasks in a Fabric will be the editing of existing channels. For a tutorial about that process, check out <a class="reference internal" href="config_update.html"><span class="doc">&lt;no title&gt;</span></a>. One popular channel update is to add an org to an existing channel. For a tutorial about that specific process, check out <a class="reference internal" href="channel_update_tutorial.html"><span class="doc">Adding an Org to a Channel</span></a>. For information about upgrading nodes after they have been deployed, check out <a class="reference internal" href="upgrading_your_components.html"><span class="doc">&lt;no title&gt;</span></a>.</p>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="ops_guide.html" class="btn btn-neutral float-right" title="Operations Guides" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="videos.html" class="btn btn-neutral" title="Videos" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Hyperledger 2020.
    <br>
      <br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
      <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">
        <img alt="Creative Commons License" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>