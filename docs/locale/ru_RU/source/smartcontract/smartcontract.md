## Смарт-контракты и чейнкод

**Целевая аудитория**: архитекторы, разработчики приложений и смарт-контрактов, администраторы

С точки зрения разработчика приложений **смарт-контракт** вместе с [реестром](../ledger/ledger.html) являются основой блокчейн-сети Hyperledger Fabric. В то время как реестр хранит факты о текущем и прошлых состояниях набора бизнес-объектов, **смарт-контракт** определяет исполняемую логику, согласно которой генерируются новые факты для добавления в реестр. **Чейнкод** обычно используется администраторами для объединения связанных смарт-контрактов перед развертыванием, но также может использоваться для низкоуровневого системного программирования сети Fabric. В этом разделе рассматривается важность **смарт-контрактов** и **чейнкода**, а также случаи и способы их применения.

В этом разделе:

* [Смарт-контракты](#smart-contract) 
* [О терминологии](#terminology)
* [Смарт-контракты и реестр](#ledger)
* [Разработка смарт-контрактов](#developlment)
* [Важность правил одобрения](#endorsement)
* [Подтвержденные транзакции](#valid-transaction) 
* [Определения каналов и чейнкода](#channels)
* [Взаимодействие смарт-контрактов](#intercommunication)
* [Системный чейнкод](#system-chaincode)

## Смарт-контракты 

Для возможности совершения транзакций, организации сперва должны определить общий набор контрактов, охватывающих общие условия, данные, правила, определения концепций и процессы. В совокупности эти контракты определяют **бизнес-модель**, которая регулирует все взаимодействия между сторонами. 

![smart.diagram1](./smartcontract.diagram.01.png) *В исполняемом коде смарт-контракта содержатся правила взаимодействия различных организаций. Приложения вызывают смарт-контракты для создания транзакций, которые далее записываются в реестр.*

В блокчейн-сети эти контракты превращаются в исполняемые программы, известные как **смарт-контракты**, которые открывают широкий спектр новых возможностей. Так, смарт-контракты могут реализовывать правила управления **любым** типом бизнес-объектов, которые автоматически применяться при выполнении смарт-контракта. Например, смарт-контракт может гарантировать, что доставка нового автомобиля будет произведена в указанные сроки или что средства будут высвобождены в соответствии с заранее оговоренными условиями, улучшая потоки товаров или капитала. Однако наиболее важно то, что выполнение смарт-контракта намного эффективнее, чем бизнес-процесс, осуществляемый человеком вручную.

На [схеме выше](#smart-contract) две организации `ORG1` и `ORG2` определили смарт-контракт `car` для запроса (`query`), передачи (`transfer`) и обновления (`update`) автомобилей.  Приложения организаций вызывают этот смарт-контракт для выполнения согласованного действия в бизнес-процессе, например, для передачи права собственности на конкретный автомобиль от организации `ORG1` к организации `ORG2`.


## Терминология

Пользователи Hyperledger Fabric часто используют термины **смарт-контракт** и **чейнкод** как синонимы. В целом, смарт-контракт определяет **логику транзакции**, которая управляет жизненным циклом бизнес-объекта, хранящегося в глобальном состоянии. Далее он упаковывается в чейнкод, который затем развертывается в блокчейн-сети.  Можно рассматривать смарт-контракты как механизм управления транзакциями. Чейнкод в свою очередь определяет, каким образом смарт-контракты упаковываются для развертывания.

![smart.diagram2](./smartcontract.diagram.02.png) *Смарт-контракт определен в чейнкоде.  Один чейнкод может содержать определения нескольких смарт-контрактов. При развертывании чейнкода все содержащиеся в нем смарт-контракты становятся доступными для приложений.*

На схеме изображен чейнкод «транспортное средство» (`vehicle`), который содержит три смарт-контракта: «автомобили» (`car`), «лодки» (`boat`) и «грузовики» (`truck`).  Также изображен чейнкод «страхование» (`insurance`), который содержит четыре смарт-контракта: «полис» (`policy`), «ответственность» (`liability`), «синдикация» (`syndication`) и «секьюритизация» (`securitization`).  В обоих случаях эти контракты охватывают ключевые аспекты бизнес-процесса, касающиеся транспортных средств и страхования. В этом разделе в качестве примера будем использовать контракт `car`. Таким образом, смарт-контракт — это программа для конкретной сферы применения и конкретных бизнес-процессов. А чейнкод — это контейнер для группы связанных смарт-контрактов.


## Реестр

Объясняя простым языком — для обновления состояний в реестре в блокчейн записываются транзакции без возможности внесения изменений. Смарт-контракт программно получает доступ к двум отдельным частям реестра — **блокчейну**, который хранит историю всех транзакций без возможности внесения изменений, и **глобальному состоянию**, в котором хранится кэш текущих значений этих состояний, и именно эти значения обычно требуются при обращении к объектам.

Смарт-контракты в основном **записывают** (put), **запрашивают** (get) и **удаляют** (delete) состояния в глобальном состоянии, а также могут запрашивать запись транзакций в блокчейн без возможности дальнейших изменений.

* Запрос **get** обычно используется для получения информации о текущем состоянии бизнес-объекта.
* Команда **put** обычно создает новый бизнес-объект или изменяет существующий в глобальном состоянии реестра.
* Команда **delete** обычно удаляет бизнес-объект из текущего состояния реестра, однако история остается неизменной.

Смарт-контракты имеют множество доступных [API-интерфейсов](../developapps/transactioncontext.html#structure). Важно заметить, что во всех случаях создания, считывания, обновления или удаления бизнес-объектов транзакциями в глобальном состоянии чейнкод содержит [неизменяемую историю записей](../ledger/ledger.html) этих изменений.

## Разработка

При разработке приложений на смарт-контракты нацелен основной фокус внимания, и, как было показано, один чейнкод может содержать любое количество смарт-контрактов.  При развертывании чейнкода в сети все смарт-контракты чейкнода становятся доступными для организаций этой сети. Это означает, что работа с чейнкодом лежит в ответственности исключительно администраторов. Всем остальным пользователям достаточно концепции смарт-контрактов.

В основе смарт-контракта лежит набор определений `транзакций`. Например, рассмотрим файл [fabcar.js](https://github.com/hyperledger/fabric-samples/blob/{BRANCH}/chaincode/fabcar/javascript/lib/fabcar.js#L93), содержащий пример транзакции смарт-контракта, которая создает новый автомобиль:

```javascript
async createCar(ctx, carNumber, make, model, color, owner) {

    const car = {
        color,
        docType: 'car',
        make,
        model,
        owner,
    };

    await ctx.stub.putState(carNumber, Buffer.from(JSON.stringify(car)));
}
```

Подробное рассмотрение примера смарт-контракта **Fabcar** приводится в руководстве [Создание первого приложения](../write_first_app.html).

С помощью смарт-контракта можно описать почти бесконечное количество вариантов бизнес-процессов, связанных с неизменностью данных при принятии решений несколькими организациями. Используя языки программирования JavaScript, Go или Java и другие, разработчики смарт-контрактов выражают существующий бизнес-процесс, в ходе которого определяются цены или условия поставки, в виде смарт-контракта. Для преобразования многовекового юридического опыта в код с помощью языка программирования все чаще нужны **аудиторы смарт-контрактов**, обладающие соответствующими юридическими и техническими знаниями. Подробная информация о проектировании и разработке смарт-контрактов приводится в разделе [Разработка приложений](../developapps/develop_applications.html).


## Одобрение 

Для каждого чейнкода предусмотрены правила одобрения, которые применяются ко всем определенным в нем смарт-контрактам. Правила одобрения очень важны — в них указывается, какие организации в блокчейн-сети должны подписать транзакцию, созданную определенным смарт-контрактом, чтобы эта транзакция была объявлена ​​**подтвержденной**. 

![smart.diagram3](./smartcontract.diagram.03.png) *Каждый смарт-контракт имеет связанные с ним правила одобрения. Правила одобрения определяют организации, которые должны одобрить транзакцию, сгенерированную смарт-контрактом, прежде чем транзакция может быть идентифицирована как подтвержденная.*

Например, правила одобрения могут определять, что три из четырех организаций блокчейн-сети должны подписать транзакцию, прежде чем она будет рассматриватсья как **подтвержденная**. Все **подтвержденные** или **неподтвержденные** транзакции добавляются в распределенный реестр, однако только **подтвержденные** транзакции обновляют глобальное состояние.

Если в правилах одобрения указано, что транзакция должна быть подписана несколькими организации, то для получения подтвержденной транзакции смарт-контракт должен быть выполнен достаточным количеством организаций. В примере [выше](#endorsement) транзакция смарт-контракта для передачи (`transfer`) автомобиля должна быть выполнена и подписана организациями `ORG1` и `ORG2`, чтобы считаться подтвержденной.

Правила обновления отличают сеть Hyperledger Fabric от других блокчейнов, таких как Ethereum или Bitcoin. В этих системах любой узел сети может создавать транзакции, которые будут считаться подтвержденными. Сеть Hyperledger Fabric более точно моделирует реальный мир — транзакции должны подтверждаться доверенными организациями в сети. Например, руководящая организация должна подписать транзакцию выдачи идентификатора (`issueIdentity`), или покупатель (`buyer`) и продавец (`seller`) автомобиля должны подписать транзакцию передачи автомобиля (`car`). Правила одобрения предусмотрены для более точного моделирования подобных реальных взаимодействий.

В заключение, правила одобрения — это лишь один из примеров [установленных правил](../access_control.html#policy) в Hyperledger Fabric. Также можно использовать другие правила для определения субъектов, которые могут запрашивать или обновлять реестр, и добавлять или удалять участников из сети. Обычно правила заранее согласуются консорциумом организаций в блокчейн-сети и могут быть изменены позже. Для этого в самих правилах определены дополнительные правила, согласно которым они могут быть изменены. И хотя эта тема требует углубленного рассмотрения, стоит отметить, что также возможно задавать [пользовательские правила одобрения](../pluggable_endorsement_and_validation.html) помимо стандартных правил, предоставляемых системой Fabric. 

## Подтвержденные транзакции

В случае обращения к смарт-контракту, он выполняется на одноранговом узле, который принадлежит определенной организации в блокчейн-сети. Контракт принимает набор входных параметров, называемых **запросом на транзакцию**, и использует их согласно внутренней программной логике для чтения и обновления реестра. Изменения глобального состояния записываются в виде **ответа на запрос на транзакцию** (или просто **ответ на транзакцию**), который содержит **набор чтения-записи** со считанными состояниями и новыми состояниями, которые должны быть записаны в реестр, если транзакция является подтвержденной. Обратите внимание, что глобальное состояние **не обновляется при выполнении смарт-контракта**.

![smart.diagram4](./smartcontract.diagram.04.png) *Все транзакции имеют идентификатор, а также запрос и ответ, подписанные некоторым количеством организаций. Все транзакции, подтвержденные или неподтвержденные, записываются в блокчейн, но только подтвержденные транзакции могут изменить глобальное состояние.*

Рассмотрим транзакцию передачи автомобиля `car transfer`. Транзакция `t3` используется для передачи автомобиля организацией `ORG1` организации `ORG2`. Обратите внимание, что транзакция имеет входные данные `{CAR1, ORG1, ORG2}` и выходные данные `{CAR1.owner = ORG1, CAR1.owner = ORG2}`, которые указывают на смену владельца с `ORG1` на `ORG2`. Также входные данные подписываются организацией-владельцем приложения `ORG1`, а выходные данные подписываются *обеими* организациями `ORG1` и `ORG2`, указанными в правилах одобрения.  Подписи генерируются с помощью закрытых ключей каждого из участников. Это означает, что любой участник сети может проверить, что все соответствующие субъекты в сети согласны с содержанием транзакции.

Транзакции распределяются по всем одноранговым узлам в сети, и **проверяются** каждым одноранговым узлом в два этапа. Сперва транзакция проверяется на наличие достаточного количества подписей от организаций в соответствии с правилами одобрения. Затем проверяется, чтобы текущее значение глобального состояния совпадало с набором чтения транзакции, когда она была подписана одобряющими узлами. Это необходимо, чтобы проверить отсутствие промежуточных обновлений. Транзакция считается подтвержденной в случае успешного прохождения двух этапов проверки. В блокчейн добавляются все транзакции независимо от того, являются ли они **подтвержденными** или **неподтвержденными**, однако только **подтвержденные** транзакции обновляют глобальное состояние.

В нашем примере `t3` является подтвержденной транзакцией, поэтому владельцем автомобиля `CAR1` становится организация `ORG2`. Однако `t4` (не показана) является неподтвержденной транзакцией, поэтому, хотя она была записана в реестр, глобальное состояние не было обновлено, и владельцем автомобиля `CAR2` остается организация `ORG2`.

Наконец, чтобы разобраться в принципах взаимодействия смарт-контрактов или чейнкода с глобальным состоянием, рекомендуем ознакомится с разделом [Пространство имен чейнкода](../developapps/chaincodenamespace.html).

## Каналы 

Hyperledger Fabric позволяет организациям одновременно быть участниками нескольких независимых блокчейн-сетей благодаря **каналам**. Присоединяясь к нескольким каналам, организация может участвовать в так называемой **сети из сетей**. Каналы позволяют эффективно совместно использовать инфраструктуру при сохранении конфиденциальности связи и обмена данными. Каналы достаточно независимы, чтобы помочь организациям разделять свой рабочий трафик при работе с разными контрагентами, а также достаточно интегрированы, позволяя организациями производить любую другую деятельность при необходимости.

![smart.diagram5](./smartcontract.diagram.05.png) *Канал предоставляют полностью независимый механизм связи для набора организаций. При записи определения чейнкода в канал, все смарт-контракты чейнкода становятся доступными для приложений этого канала.* 

Несмотря на то, что программный код смарт-контракта устанавливается в пакете чейнкода на одноранговых узлах организации, участники канала могут выполнять смарт-контракт только после записи определения чейнкода в канале. **Определение чейнкода** — это структура, которая содержит параметры управления работой чейнкода. Эти параметры включают имя, версию и правила одобрения чейнкода. Каждый участник канала подтверждает параметры чейнкода, соглашаясь с определением чейнкода от имени своей организации. При одобрении конкретного определения чейнкода достаточным количеством организаций (по умолчанию большинством), такое определение может быть записано в канале. Затем участники канала могут использовать смарт-контракты из чейнкода в соответствии с правилами одобрения, указанными в определении чейнкода. Правила одобрения применяется в равной степени ко всем смарт-контрактам, определенным в одном чейнкоде.

В примере [выше](#channels) контракт `car` определен в канале `VEHICLE`, а договор `insurance` — в канале `INSURANCE`. Определение `car` в чейнкоде содержит правила одобрения, согласно которым организации `ORG1` и `ORG2` должны подписать транзакции, прежде чем их можно будет считать подтвержденными. В определении чейнкода для контракта `insurance` указывается, что подтверждение транзакции может осуществлять только организация `ORG3`. Организация `ORG1` является участником сразу двух сетей — канала `VEHICLE` и сети `INSURANCE`, и может взаимодействовать с организациями `ORG2` и `ORG3` в этих двух сетях.

Определение чейнкода предоставляет участникам канала возможность согласовать управление чейнкодом перед использованием смарт-контрактов для проведения транзакций в канале. Согласно примеру выше, организации `ORG1` и `ORG2` намереваются одобрять транзакции, которые вызывают контракт `car`. Поскольку правила по умолчанию требуют одобрения чейнкода большинством организаций, обе организации должны согласиться с правилами одобрения `AND {ORG1, ORG2}`. В противном случае организации `ORG1` и `ORG2` одобрят разные определения чейнкода и в результате не смогут записать определение чейнкода в канале. Благодаря такому процессу гарантируется, что транзакция смарт-контракта `car` должна быть одобрена обеими организациями. 

## Взаимодействие 

Смарт-контракт может вызывать другие смарт-контракты в канале, в котором он установлен, а также в других каналах. Таким образом, смарт-контракты могут считывать и обновлять данные глобального состояния, к которым в противном случае у них не было бы доступа из-за ограничений пространств имен.

Для такого межконтрактного взаимодействия предусмотрены ограничения, которые подробно описаны в разделе [Пространство имен чейнкода](../developapps/chaincodenamespace.html#cross-chaincode-access).

## Системный чейнкод

Определенные в чейнкоде смарт-контракты содержат правила для проведения соответствующих бизнес-процессов, согласованные набором организаций в блокчейн-сети. Однако в чейнкоде также может быть определен низкоуровневый программный код, который применяется к любым *системным* взаимодействиям, не связанным со смарт-контрактами для конкретных бизнес-процессов.

Ниже приведены различные типы системных чейнкодов и связанных с ними сокращений:

* `_lifecycle` выполняется на всех одноранговых узлах и контролирует установку чейнкода на одноранговых узлах, утверждение определений чейнкодов организациями и запись определений чейнкодов в каналах. Описание реализации процесса жизненного цикла чейнкода Fabric в `_lifecycle` приведено в [этом разделе](../chaincode_lifecycle.html).

* Чейнкод системы жизненного цикла (LSCC) управляет жизненным циклом чейнкода в сетях Fabric версий 1.x. В этих версиях требовалось, чтобы чейнкод создавался или обновлялся в каналах. Систему LSCC можно по-прежнему использовать для управления чейнкодом, если функционал приложений канала имеют версию V1_4_x или ниже.

* **Чейнкод конфигурации системы(CSCC)** выполняется на всех одноранговых узлах для обработки изменений, вносимых в конфигурацию канала, например, при обновлении установленных правил.  Более подробно об этом процессе рассказано в следующем [разделе] (../configtx.html#configuration-updates), посвященном чейнкоду.

* **Чейнкод системы запросов (QSCC)** выполняется на всех одноранговых узлах и предоставляет API-интерфейсы для доступа к реестру, включая такие команды, как запрос блока, запрос транзакции и другие. Описание этих API-интерфейсов в контексте транзакций приведено в следующем [разделе](../developapps/transactioncontext.html). 

* **Чейнкод системы одобрения (ESCC)** выполняется при подтверждении одноранговыми узлами криптографической подписи ответа на транзакцию. Подробное описание реализации этого процесса системой ESCC приведено в [этом разделе](../peers/peers.html#phase-1-offer).

* **Чейнкод системы валидации (VSCC)** проверяет транзакцию, осуществляя проверку выполнения требований правил одобрения и соответствие версии набора чтения-записи. Больше информации о реализации этого процесса системой VSCC приведено в [этом разделе](../peers/peers.html#phase-3-validation).

Разработчики и администраторы сетей Fabric могут изменять системные чейнкоды для собственных целей с помощью низкоуровневого программирования. Однако разработка и управление системными чейнкодами является особым направлением, не связанным с разработкой смарт-контрактов, и обычно не требуется для успешного функционирования сети. Системные чейнкоды следует изменять с особой осторожностью, поскольку они имеют фундаментальное значение для правильного функционирования сети Hyperledger Fabric. Например, при ошибочной реализации системного чейнкода разные одноранговые узлы могут обновлять свои копии глобального состояния или блокчейна по-разному. Отсутствие консенсуса является одной из форм **разветвления реестра**. Такая ситуация — очень нежелательна в блокчейн-сети.
