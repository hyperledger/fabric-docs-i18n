# 区块链网络

这个话题会描述在一个**概念层级上**，Hyperledger Fabric 是如何允许组织间以区块链网络的形式进行合作的。如果你是一个架构师，管理员或者开发者，你可以通过这个话题来理解在 Hyperledger Fabric 区块链网络中的主要结构和流程组件。这个话题会使用一个可管理的工作的例子来介绍在一个区块链网络中的主要组件。

当阅读完这个话题并且理解规约的概念后，你就能够完全理解组织在建立管控一个部署的 Hyperledger Fabric 网络而需要做的决策。你也能够理解组织是如何使用定义的规则来管理网络的演变的 - 一个 Hyperledger Fabric 的主要特点。简言之，你会理解 Hyperledger Fabric 的主要技术组件以及组织对于他们所要做的决策。

## 什么是一个区块链网络

一个区块链网络是一个为应用程序提供账本及智能合约（chaincode）服务的技术基础设施。首先，智能合约被用来生成交易，接下来这些交易会被分发给网络中的每个 peer 节点，这些交易会被记录在他们的账本副本上并且是不可篡改的。这个应用程序的用户可能是使用客户端应用的最终用户，或者是一个区块链网络的管理员。

在大多数的额情况下，多个[组织](../glossary.html#organization) 会聚集到一起作为一个[联盟](../glossary.html#consortium) 来形成一个网络，并且他们的权限是由一套在网络最初被配置的时候联盟成员都同意的[规则](../glossary.html#policy)来决定的。并且，网络的规则可以在联盟中的组织同意的情况下随时地被改变，就像当我们讨论 *修改规则* 概念的时候将要发现的那样。

## 示例网络

在我们开始前，让我们来展示一下我们最终要做的东西吧！这是一个图表展示了我们的例子网络的 **最终 state**。

不必担心这个看起来非常复杂！当我们学习这个话题的过程中，我们会一部分一部分地构建起这个网络，所以你能够了解组织 R1, R2, R3 和 R4 是如何为网络中提供基础设施并且从中获益。这个基础设施实现了区块链网络，并且它是由来自网络中的组织都同意的规则来管理的 - 比如，谁可以添加新的组织。你会发现应用程序是如何消费账本以及区块链网络所提供的智能合约服务。

![network.structure](./network.diagram.1.png)

*对于组织 R1、R2、R3 和 R4，他们共同决定，并且达成了一个协议，他们将会设置并开发一个 Hyperledger Fabric 网络。R4 被分配作为网络的初始者 - 它具有权利来设置网络的初始版本。R4 不会在网络中去进行任何的业务交易。R1 和 R2 在整体网络中有一个进行私有的沟通的需求，R2 和 R3 也是。组织 R1 有一个客户端的应用能够在 channel C1 中进行业务的交易。组织 R2 有一个客户端应用可以在 channel C1 和 C2 中进行类似的工作。组织 R3 可以在 channel C2 中做这样的工作。Peer 节点 P1 维护了跟 C1 相关的账本 L1 的副本。Peer 节点 P2 维护了与C1 相关的账本 L1 和与 C2 相关的账本 L2 的副本。Peer 节点 P3 维护了于 C2 相关的账本L2 的副本。这个网络是根据在 network configuration NC4 中指定的规则来进行管理的，整个网络是在组织 R1 和 R4 下管理IDE。Channel C1 是根据在 channel configuration CC1 中指定的规则来管理的，这个 channel 是在组织 R1 和 R2 下管理的。Channel C2 是根据在 channel configuration CC2 中指定的规则来管理的，这个 channel 是在组织 R2 和 R3 下管理的。这有一个 ordering service O4 作为这个网络 N 的一个网络管理员节点，并且使用系统的 channel。Ordering service 同时也支持应用的 channels C1 和 C2，来对交易进行排序、加入区块然后被分发。每个组织都有一个首选的证书认证机构 Certificate Authority。*

## 创建网络

让我们从头开始来创建网络的基础：

![network.creation](./network.diagram.2.png)

*当一个 Ordering Service 被启动后就形成了这样的一个网络。在我们的例子网络 N 中，ordering service O4 由一个单独的节点组成，是根据一个 Network Configuration NC4 来进行配置的。在网络层级上，Certificate Authority CA4 被用来向管理员和 Organization R4 的网络节点分配身份信息。*

我们能够看到，在定义一个 **netwwork N** 的时候，第一件事情就是定义一个 **ordering service, O4**。对于一个网络在最初就考虑以管理员节点的形式定义这个 ordering service 是非常有帮助的。就像在之前同意的，O4 最初被配置并且由 organization R4 的一个管理员来启动，并且是 host 在 R4。配置 NC4 包含了描述对于这个网络的起始的一套管理能力的规则。最初这个仅仅允许 R4 能够在网络中行驶这样的权利。这个在将来会变化，我们稍后会看到，但是目前 R4 是这个网络中唯一的一个成员。

### 证书认证机构

你也能够看到一个证书认证机构，CA4，它会被用来给管理者和网络节点颁发证书。CA4 在我们的网络中扮演着重要的角色，因为它会分配 X.509 证书，这个证书能够用来识别属于 organization R4 的组件。由 CAs 颁发的证书也可以用来为交易提供签名，来表明一个 organization 对交易的结果进行背书 - 这是该笔交易可以被接受并记录到账本上的一个前提条件。让我们对这个有关 CA 的两个方面更详细的介绍一下。

首先，在区块链网络中的不同组件之间，彼此是使用证书来标识自己是来自于一个指定的组织的。这就是为什么通常会有多个 CA 来支持一个区块链网络 - 不同的组织通常会使用不同的 CAs。在我们的网络中，我们会使用 4 个 CAs，每个组织会有一个 CA。事实上，CAs 是非常重要的，所以 Hyperledger Fabric 提供给你一个内置的（被称为 *Fabric-CA*）来帮助让事情运转，尽管在实际当中，组织将会选择使用它们自己的 CA。

将证书同成员组织进行匹配是同时一个称为成员服务提供者（[Membership Service Provider, MSP](../glossary.html#membership-services)）的结构来实现的。Network configuration NC4 使用一个命名的 MSP 来识别由 CA4 分发的证书的属性，这些证书会关联到组织 R4 下的证书持有者。NC4 接下来会使用这个在规则中的 MSP 名字来分配在网络资源上的特殊权利。这个规则的一个例子就是，在 R4 中识别管理员，这个管理员可以向网络中添加新的成员组织。我们没有在这些图标中显示 MSPs，因为他们会很杂乱，但是他们是非常重要的。

第二点，接下来我们会看到由 CA 签发的证书是如何在[交易](../glossary.html#transaction)的生成和验证的流程中处于核心位置的。特别的，X.509 证书被用于客户端应用的[交易提案](../glossary.html#proposal)和智能合约的[交易反馈](../glossary.html#response)，来对[交易](../glossary.html#transaction)进行数字化的签名。接下来持有账本副本的网络节点在接受将交易更新到账本之前会验证交易签名是否有效。

让我们重新整理我们的区块链网络例子的基本结构。这有一个资源，网络 N，有一系列的用户能够访问这个网络，这些用户是由一个证书权利机构 CA4 定义的，他们具有在一个 network configuration NC4 中包含的规则中所描述的一系列的在网络 N 中的权利。当我们配置和启动 ordering service 节点 O4 的时候上边讲的事情都会发生。

## 添加网络管理员

NC4 最初被配置为仅仅允许 R4 用户在网络中具有管理的权限。在接下来的阶段，我们会允许组织 R1 用户也具有管理的权限。让我们来看看网络是如何演变的：

![network.admins](./network.diagram.2.1.png)

*组织 R4 更新了网络配置来使组织 R1 也成为了管理员。现在 R1 和 R4 在网络配置中便具有了相同的权限。*

我们看到了新的组织 R1 变成了管理员 - R1 和 R4 现在在网络中具有了相同的权限。我们看到证书认证机构 CA1 也被添加进来了 - 他可以用来标识来自于 R1 组织的用户。现在从 R1 和 R4 来的用户就已经是网络的管理员了。

尽管排序节点 O4 是运行在 R4 的基础设施上的，当 R1 能够获得网络访问的话， R1 在 O4 中也共享了管理的权限。也就是说 R1 或者 R4 可以更新这个网络配置 NC4 来允许组织 R2 进行网络维护中的部分功能。通过这种方式，尽管 R4 运行着排序服务，但是 R1 在其中也具有着全部的管理员权限，R2 具有着有限的创建新的联盟的权限。

在这个最简单的模式中，排序服务在网络中是一个独立的节点，就像你在例子中看到的。排序服务通常回是多节点的，也可以被配置为在不同组织中的不同节点上。比如，我们可能会在 R4 中运行 O4 并连接到 O2，O2 是在组织 R1 中的另一个排序节点。通过这种方式，我们就有了一个多节点、多组织的管理结构。

我们会在[之后](#the-ordering-service)讨论更多关于排序服务的话题，但是目前只需要把排序服务当成是一个管理者，它给不同的组织提供了对于网络的管理的权限。

## 定义联盟

尽管这个网络当前可以被 R1 和 R4 管理，但是只有这些还是太少了。我们需要做的第一件事就是定义一个联盟。这个词表示 “具有着共同命运的一个群组”，所以这个是在一个区块链网络中合理地选择出来的一些组织。

让我们来看看如何定义一个联盟：

![network.consortium](./network.diagram.3.png)

*一个网络管理员定义了一个包含两个成员的联盟 X1，包含组织 R1 和 R2.这个联盟的定义被存储在了网络配置 NC4 中，回来接下来的网络开发中被使用。CA1 和 CA2 是这两个组织对应的证书认证机构。*

由于 NC4 的配置方式，只有 R1 和 R4 能够创建新的联盟。这个图标显示了一个新的联盟， X1，它定义了 R1 和 R2 是它的联盟组织。我们也看到了 CA2 也被添加进来来标识来自于 R2 的用户。注意一个联盟可以包含任意数量的组织 - 我们仅仅包含了 2 个组织作为一个最简单的配置。

为什么呢联盟这么重要？我们能够看到一个联盟定义了网络中的一部分组织，他们共享了一个彼此能够**交易**的需求 - 着这个 case 中是 R1 和 R2 能够进行交易。这对于一组具有着共同的目标的组织来说是有意义的。

这个网络虽然最初仅包含一个组织，现在已经由更大的一套组织来管控了。我们可以由这种方式开始，R1、R2 和 R4 有着共享的管控权，但是这样的构成更容易被理解。

现在我们要使用联盟 X1 来创建一个对于 Hyperledger Fabric 区块链非常重要的部分 - **一个 channel**。

## 为联盟创建一个 channel

现在让我们来创建对于 Fabric 区块链网络的关键部分 - 一个 channel。一个 channel 是一个联盟中的成员彼此进行沟通的主要沟通机制。在一个网络中可能会有多个 channels，但是现在让我们从一个开始。

让我们来看一下第一个 channel 是如何被添加到这个网络中的：

![network.channel](./network.diagram.4.png)

*一个为 R1 和 R2 的 channel C1 通过使用联盟定义 X1 被创建起来。这个 channel 是通过 channel configuration CC1 来进行管理的，是完全同 network configuration 独立开来的。CC1 是由 R1 和 R2 来管理的，他们通过 C1 具有同等的权利。R4 在 CC1 中是没有任何权利的。*

Channel C1 为联盟 X1 提供了一个私有的沟通机制。我们能够看到 channel C1 已经关联到了排序服务 O4 但是这并没有附带任何功能。在网络开发的下一个阶段，我们将会连接不同的组件比如客户端应用和 peer 节点。但是到目前为止，一个 channel 就代表了将来要进行的连接的**可能性**。

尽管 C1 是网络 N 中的一部分，它还是跟这个网络非常区别开来的。同时也要注意到组织 R3 和 R4 并没有在这个 channel 中 - 因为这个 channel 仅仅是为了处理在 R1 和 R2 之间进行的交易的。在前一步中，我们看到了 R4 是如何能够为 R1 分配权限来创建新的联盟。讲到 R4 同样**也**允许R1 来创建 channel 还是很有帮助的。在这个图表中，组织 R1 和 R4 创建了 channel C1。再次强调，一个 channel 可以包含任意数量的组织来连接它 - 我们目前只包含了两个组织，这是一个最简单的配置。

再一次需要注意的是 channel C1 是如何具有一个同网络配置 NC4 完全分开的配置 CC1。CC1 包含了赋予 R1 和 R2 在 channel C1 上的权利的规则 - 就像我们看到的那样，R3 和 R4 在这个 channel 中没有权限。R3 和 R4 只有被 R1 或者 R2 添加到在 channel configuration CC1 中适合的规则后才能够跟 C1 进行交互。这样做的一个例子是定义谁能够向 channel 中添加新的组织。特别要注意的是 R4 是不能够将它自己添加到 channel C1 中的 - 这个只能由 R1 或者 R2 来授权添加。

为什么 channel 会如此重要？Channels 非常有用，因为提供了一个联盟成员之间进行私有沟通和私有数据的机制。Channels 提供了同其他 channel 以及整个网络的隐私性。Hyperledger Fabric 在这一点上是很强悍的，因为它允许组织间共享基础设施单同时又保持了私有性。这里并不存在矛盾 - 网络中不同的联盟之间会需要将不同的信息和流程进行适合的共享，channels 为这些提供了有效的机制。Channels 提供了一个有效的基础设施共享但是将数据及沟通又变得具有隐私性。

我们也能够看到一旦一个 channel 被创建之后，它会真正地代表了 “在网络中解放出来”。从现在开始和未来，只有在 channel configuration 中指定的组织才能够控制它。同样的，从现在开始，之后的对于 network configuration NC4 的任何改动不会对 channel configuration CC1 造成任何直接的影响。比如如果联盟定义 X1 被改动了，它不会影响 channel C1 的成员。所以 channels 是有用的，因为他们允许构成 channel 的组织间进行私有的沟通。并且，在一个 channel 中的数据跟网络中的其他部分是完全隔离的，包括其他的 channels。

同时，这里还有一个被排序服务使用的特殊的 **系统 channel**。它跟常规的 channels 是完全一样的方式运行的，由于这个原因，常规的 channels 有的时候又被称为 **应用 channel**。我们通常不会担心这个 channel，但是[之后](#the-ordering-service)我们会更详细的讨论它。

## Peers 和 账本

现在，让我们开始使用 channel 来将这个区块链网络以及组织的组件关联到一起吧。在网络开发的下一个阶段，我们能够看到我们的网络 N 又新增了两个组件，可以称作 peer 节点 P1 和 一个账本实例 L1。

![network.peersledger](./network.diagram.5.png)

*一个 peer 节点 P1 加入了 channel C1。物理上 P1 会存储账本 P1 的副本。P1 和 O4 可以使用 channel C1 来进行通信。*

Peer 节点是存储区块链账本副本的网络组件。至少，我们已经开始看到了一些区块链标志性的组件了！P1 在这个网络中的目的是单纯地放置被其他人访问的账本 L1 的副本。我们可以想象 L1 会被 **物理地** 存储在 P1 上，但是 **逻辑上** 是存储在 channel C1 上。当我们向 channel 中添加更多的 peers 之后，我们对这些就会更加清楚。

P1 的配置中一个关键部分就是一个由 CA1 颁发的 X.509 身份信息，它将 P1 和组织 R1 关联了起来。当 P1 启动之后，它就可以使用排序 O4 **加入** channel C1。当 O4 收到这个加入请求，它会使用 channel configuration CC1 来决定 P1 在这个 channel 中的权限。比如，CC1 决定 P1 是否能够向账本 L1 中读和/或者写信息。

注意 peers 是如何被拥有他们的组织加入到 channels 的，尽管我们仅仅加了一个 peer，我们将会看到在网络中是如何做到在偶 channels 上具有多 peer 节点的。我们也会在之后的部分看到 peers 能够代表的不同的角色。

## 应用程序和智能合约链码

现在 channel C1 拥有了一个账本，我们可以连接客户端应用来使用由 peer 提供的服务了。

注意网络是如何变化的：

![network.appsmartcontract](./network.diagram.6.png)

*一个智能合约 S5 被安装在了 P1 上。在组织 R1 中的客户端应用 A1 可以通过 peer 节点 P1 使用 S5 来访问账本。A1，P1 和 O4 都加入了 channel C1，他们都可以使用由这个 channel 提供的通信设备。*

在网络开发的下一个阶段，我们可以看到客户端应用 A1 能够使用 channel C1 来连接指定的网络资源 - 在这个 case 中，A1 能够连接 peer 节点 P1 和 order 节点 O4。再次注意，看看 channels 是如何处在网络和组织的组件之间进行沟通的中心的。就像 peers 和 orderers，一个客户端应用也会有一个使它和一个组织相关联的身份信息。在我们的例子中，客户端应用 A1 是跟组织 R1 相关联的，尽管它处在 Fabric 区块链网络的外边，但它是可以通过 channel C1 跟网络相连接的。

现在我们能够清楚地看到 A1 能够通过 P1 直接访问账本 L1，但是事实上，所有的访问都是由一个称为智能合约 chaincode S5 的特殊的程序来管理的。将 S5 理解为定义对于账本的常规访问模式，S5 提供了完整定义的一套方式来对账本 L1 进行查询及更新。简言之，客户端应用 A1 需要通过智能合约 S5 来获得账本 L1。

智能合约可以被每个组织的应用开发者创建来实现一个在联盟成员间共享的业务流程。智能合约被用来帮助生成可以被分发到网络中每个节点的交易。我们会在接下来详细讨论。当网络变得更大了之后，这个会更容易理解。现在，需要理解的重要的事情是，为了达到这一点，两项操作在智能合约执行，它必须被 **安装**，然后在一个通道中被 **定义**。

Hyperledger Fabric 用户经常会在内部使用名词 **智能合约** 以及 **链码**。大体上来说，一个智能合约定义了 **交易逻辑**，它控制了在世界状态中包含的一个业务对象的生命周期。然后它会被打包进一个链码中，这个链码会被部属到一个区块链网络中。可以把智能合约想象为管理的交易，链码则管理着智能合约应该如何被打包部署。

### 安装一个链码包

在一个智能合约 S5 被开发完之后，组织 R1 中的一个管理员必须要把它 [安装](../glossary.html#install)到 peer 节点 P1 上。这是一个很简单的操作。当结束之后，P1 就完全了解了 S5。特别的是，P1 能够看到 S5 的**实现**逻辑 - 用来访问账本 L1 的程序代码。我们将这个同 S5 的 **接口** 进行对比，接口只是描述了 S5 的输入和输出，但是没有它的实现。

当一个组织在一个 channel 中有多个 peers，它可以选择哪个节点可以安装智能合约，它不需要再每一个 peer 上都安装一个智能合约。


### 定义一个链码

尽管一个链码会被安装在独立组织的 peers 上，但是它是在一个 channel 范围内被管理和维护的。每个组织需要批准一个 **链码定义**，和一系列的参数来定义在一个 channel 中链码应该被如何使用。一个组织必须要批准一个链码定义，才能使用已经安装的智能合约来查询账本和为交易背书。在我们的例子中，只有一个单独的 peer 节点 P1，一个组织中的管理员 R1 必须要批准 S5 的链码定义。

在链码定义能够被提交到 channel 并且用来同 channel 账本进行互动之前，需要有有效数量的组织来批准一个链码的定义（大部分的，默认）。因为 channel 中只有一个成员，R1 的管理员可以提交 S5 的链码定义到 channel C1。当这个定义被提交后，S5 就可以被客户端应用 A1 来[调用](../glossary.html#invoke)了！

注意，虽然在这个 channel 上的每个组件现在都可以访问 S5，但是他们是不能够看到它的程序逻辑的。这对于安装了这个智能合约的节点还是保持隐私性的，在我们的例子中指的是 P1。从概念上讲，这意味着实际上是智能合约 **接口** 被定义ing提交到一个 channel，而不是安装了只能合约的 **实现**。为了强调这个想法，安装一个智能合约展示了我们是如何考虑将它 **物理地存储** 在一个 peer 节点上，然而实例化一个智能合约展示了我们是如何将它 **逻辑地存储** 在 channel 中。

### 背书策略

在链码定义中提供的信息中的一个最重要的部分就是一个[背书策略](../glossary.html#endorsement-policy)。它描述了在交易被其他的组织接受并存储在他们的账本副本上之前，哪些组织必须要同意此次交易。在我们的例子网络中，只有当 R1 和 R2 对交易进行背书之后，交易才能够被接受并存储到账本 L1 中。

将链码定义提交到 channel 将背书策略放置在了 channel 账本上，它允许了 channel 中的每个任何成员都可以访问。你可以在[交易流程话题](../txflow.html)中阅读更多关于背书策略的内容。

### 调用一个智能合约

当一个智能合约被安装在了一个 peer 节点并且在一个 channel 上被定义之后，它就可以被一个客户端应用来[调用](../glossary.html#invoke)了。客户端应用是通过发送交易提案给在智能合约中的背书策略所指定的组织里的 peer 节点方式来调用智能合约的。这个交易的提案会作为智能合约的输入，智能合约会使用它来生成一个背书交易 response，这会由 peer 节点返回给客户端应用。

这些交易的 responses 会和交易的提案被打包在一起来形成一个完整的经过背书的交易，他们会被分发到整个网络。我们会在之后更详细的了解，现在理解应用是如何调用智能合约来生成经过背书的交易就已经足够了。

在网络开发的这个阶段，我们能够看到组织 R1 彻底参阅这个网络。它的应用 - 由 A1 开始 - 能够通过智能合约 S5 访问账本 L1，并生成将要被 R1 背书的交易，最后会被接受并添加到账本中，因为这满足了背书策略。

## 网络设置结束

我们的目标是为联盟 X1（由组织 R1 和 R2构成） 创建一个 channel。对于网络开发的下一个阶段是组织 R2 将它的基础设施添加到网络中。

让我们看一下网络是如何演进的：

![network.grow](./network.diagram.7.png)

*这个网络通过增加新的组织 R2 的基础设施变得更大了。具体来说，R2 添加了 peer 节点 P2，它会存有账本 L1 的一个副本，和 chaincode S5。R2 像 R1 一样批准了相同的链码定义。P2 也加入了 channel C1，也有一个客户端应用 A2。A2 和 P2 使用由 CA2 颁发的证书来标识 A2 和 P2。所有这些都说明了 A1 和 A2 能够使用 peer 节点 P1 或者 P2 来调用在 C1 上的 S5。*

我们能够看到组织 R2 在 channel C1 上添加了一个 peer 节点 P2。P2 也存储了账本 L1 和智能合约 S5 的副本。R2 也添加了客户端应用 A2，它能够通过 channel C1 连接到网络。为了达到这个，组织 R2 中的管理员添加了 peer 节点 P2 并且将它加入到 channel C1，就像 R1 的管理员一样的方式。管理员也必须要像 R1 那样批准相同的链码定义。

我们创建了我们的第一个可运行的网络！在网络开发的当前阶段，我们定义了一个 channel，在这个 channel 中组织 R1 和 R2 能够彼此进行交易。特别的是，这意味着 A1 和 A2 能够使用在 channel C1 上的智能合约 S5 和账本 L1 来生成交易。

### 生成并接受交易

相比较于经常会存有账本副本的 peer 节点，我们能够看到两种类型的 peer 节点，一类是存储智能合约而另一类则不存。在我们的网络中，每个 peer 节点都会存储智能合约的副本，但是在一个更大的网络中，会存在更多的 peer 节点并且没有存储智能合约的副本。如果一个智能合约被安装到一个 peer 节点的话，这个 peer 节点仅仅能够*运行*这个智能合约，但是这个 peer 节点可以通过连接到一个 channel 来*了解*一个智能合约的接口信息。

对于没有安装智能合约的 peer 节点，我们不应该认为他们在某种程度上是不对的。更多情况下，带有智能合约的 peer 节点通常会拥有一个特殊的能力 - 来帮助**生成**交易。需要注意的是所有的 peer 节点都可以**验证**并**接受**或者**拒绝**交易存入他们的账本 L1 副本中。然而，只有安装了智能合约的 peer 节点才能够参与交易**背书**的流程，这是生成一笔有效交易的核心。

我们不需要担心交易是如何生成的详细信息，分布式的并且被接受的 - 只需知道我们有一个区块链网络，在这个网络中组织 R1 和 R2 能够共享由账本记录的交易信息和流程就够了。我们会在其他的部分学习更多关于交易、账本以及智能合约。

### Peers 类型

在 Hyperledger Fabric 中，所有的 peers 都是一样的，基于这个网络是如何被配置的，这些 peer 节点能够担当多个角色。我们现在对于一个描述这些角色的典型的网络拓扑已经有足够的理解了。

  * [*提交 peer*](../glossary.html#commitment). 在一个 channel 中的每个 peer 节点都是一个 committing peer。他们会接收生成的交易的区块，在这些区块以一种附加的操作被提交到 peer 节点的账本副本中之前，他们会被验证。

  * [*背书 peer*](../glossary.html#endorsement). 每一个带有一个智能合约的 peer *可以*作为一个 endorsing peer。然而，想要*成为*一个真正的 endorsing peer，在 peer 上的智能合约必须要被一个客户端应用使用，来生成一个被数字签名的交易的 response。这个 *endorsing peer* 术语就是对这个事实的真实参考。

    对于一个智能合约的一个背书策略明确了在交易能够被接受并且记录到 commiting peer 的账本副本之前，都哪些组织的 peer 需要为交易提供数字签名。

这些是 Peer 的两个主要类型，一个 peer 可以担任的两种其他的角色:

  * [*Leader peer*](../glossary.html#leading-peer). 当一个组织在一个 channel 中具有多个 peers 的时候，会有一个 leader peer，它是一个节点来负责将交易从 order 节点分发到该组织中其他的 committing peers。一个节点可以选择参与静态的或者动态的 leadership 的选择。

    这个是很有用的，从管理者的角度来考虑的话会有两套 peers - 一套是具有静态 leader 选择的，另一套是带有动态的 leader 选择的。对于静态的，0 个或者多个 peers 可以被配置为 leader。对于动态的，一个 peer 会被选举成为 leader。另外，在动态选择 leader 中，如果一个 leader peer 出错了，那么剩下的 peers 将会重新选举一个 leader。

    这意味着一个组织的 peers 可以有一个或者多个 leaders 连接到 ordering service。这个对于一个大型的处理大量的交易的网络有助于改进弹性以及可扩展性。

  * [*Anchor peer*](../glossary.html#anchor-peer). 如果一个 peer 需要同另外一个组织的一个 peer 进行通信的话，那么它可以使用对方组织的 channel configuration 中定义的 anchor peers。一个组织可以拥有 0 个或者多个 anchor peers，并且一个 anchor peer 能够帮助很多不同的跨组织间的通信场景。

需要注意的是，一个 peer 可以同时是一个 committig peer，endorsing peer，leader peer 和 anchor peer。只有 anchor peer 是可选的 - 对于所有实际的目的，这里总会有一个 leader peer 和至少一个 endorsing peer，和至少一个 committing peer。

### 向 channel 中添加组织和 peers

当 R2 加入到 channel 的时候，组织必须要向它的 peer 节点 P2 上安装智能合约 S5。这很明显 -- 如果应用 A1 或者 A2 想要使用在 peer 节点 P2 上的 S5 来生成交易的话，它必须首先被展示；安装是这个可以发生的机制。现在，peer 节点 P2 有了一个智能合约和账本的物理的副本，像 P1 一样，它可以生成并接受交易到它的账本 L1 副本上了。

R2 必须要像 R1 那样批准相同的链码定义，才能够使用智能合约 S5。因为链码定义已经被组织 R1 提交到了 channel，当 R2 的组织批准了链码定义并且安装了链码包之后，R2 就可以使用链码了。提交的交易只需要发生一次。一个新的组织可以在他们批准了 channel 的其他成员同意的链码参数之后就可以使用链码了。因为对于链码定义的批准是发生在组织级别的，R2 能够只需要批准链码定义一次，然后就可以将多个 peers 加入到安装了链码包的 channel。然而，如果 R2 想改变链码的定义，那么 R1 和 R2 需要为他们的组织批准一个新的定义，然后其中的一个组织需要将定义提交到 channel。

在我们的网路中，我们能够看到 channel C1 连接了两个客户端应用，两个 peer 节点和一个ordering service。因为这里只有一个 channel，这里也就只有一个跟这个 channel 组件交互的 **逻辑** 账本。Peer 节点 P1 和 P2 具有相同的账本 L1 的副本。智能合约 S5 的副本通常会使用相同的编程语言来进行相同的实现，如果不是的话，他们也必须要完全的相同。

我们能够看到，对网络中的额外节点保持谨慎能够帮助支持不断增长的吞吐量、稳定性以及弹性。比如，在一个网络中有更多的 peers 将能够允许更多的应用来间接这个网络，并且在一个组织中有多个 peers 在发生计划的和非计划的宕机的时候可以提供额外的弹性。

这意味着通过配置复杂的拓扑结构来支持多种不同的维护目标是可能的 - 关于一个网络要有多大是没有任何理论上的限制的。并且，一个单独的组织内的 peers 有效的发现彼此并进行通信的技术机制 - [gossip 协议](../gossip.html#gossip-protocol) - 将会容纳大量的 peer 节点来支持这样的拓扑。

仔细地使用网络和 channel 策略允许庞大的网络也能够被很好的管理。组织可以随意地向网络中添加 peer 节点，只要他们向网络同意的策略取得了确认。网络及 channel 的策略在对于描绘一个去中心化网络中的自主和受管控之间创建了平衡。

## 简化视觉词汇表

我们现在要将展现我们的样例区块链网络的视觉词汇表简化一下。随着网络的成长，之前帮助我们理解 channels 的连接线将会变得越发笨拙。设想一下如果我们添加了另外一个 peer 或者客户端应用，又或者另外一个 channel 的话，我们的图表将会变得有多复杂。

为网络中添加更多内容是我们接下来马上要做的，在我们做这个之前，让我们来一起简化一下诗句词汇表把。下边是我们开发到现在为止，一个简化过的展现我们网络的图表：

![network.vocabulary](./network.diagram.8.png)

*这个图表像下边这样展示了在网络 N 中和 channel C1 有关的事实：客户端应用 A1 和 A2 能够通过 peer P1 和 P2 以及排序节点 O4 使用 channel C1 来进行通信。Peer 节点 P1 和 P2 可以使用 channel C1 的通信服务。排序服务 O4 可以使用 channel C1 的通信服务。Channel 配置 CC1 应用于 channel C1。*

注意到的是这个网络的图表通过将 channel 连线替换成了连接点的方式进行了简化，连接点显示为一个蓝色的圆圈，里边包含了 channel 数字。没有任何的信息丢失。这种展现方式更加的可扩展，因为它去除了交叉的连接线。这个让我们能够更清晰地展现更大的网络。我们通过更加关注在组件和一个 channel 之间的连接点，而不是关注 channel 本身的方式实现了这样的简化。

## 添加另外一个联盟定义

在网络开发的下一个阶段，我们引入了组织 R3.我们将会为 R2 和 R3 一个新的独立的应用 channel，这能够允许他们之间可以进行交易。这个应用 channel 会同之前定义的 channel 完全分离开来，所以 R2 和 R3 的交易信息会对他们保持良好的隐私性。

让我们回到网络级别并且为 R2 和 R3 定义一个新的联盟，X2：

![network.consortium2](./network.diagram.9.png)

*来自于 R1 或者 R4 的一个网络管理员添加了一个新的联盟定义，X2，其中包含了 R2 和 R3。这将会被用来为 X2 定义一个新的 channel。*

注意到现在网络中已经有两个联盟被定义了：对于组织 R1 和 R2 的联盟 X1，以及对于组织 R2 和 R3 的联盟 X2。联盟 X2 被引入是为了能够为 R2 和 R3 创建一个新的 channel。

一个新的 channel 只能够由 network configuration policy，NC4 中指定的组织比如 R1 或者 R4 来创建，因为只有他们才有相关的权限。这是一个区分在网络级别有哪些组织可以管理资源和在 channel 级别谁能管理资源的一个 policy 的例子。在工作中观察这些策略能够帮助我们理解为什么Hyperledger Fabric 具有一个复杂的**分层的**策略结构。

实际上，联盟定义 X2 已经被添加进了 network configuration NC4。我们会在文档的其他部分讨论具体的技术细节。

## 添加一个新的 channel

让我们使用这个新的联盟定义，X2 来创建一个新的 channel，C2。为了帮助加强你对于简单 channel 符号的理解，我们会使用两种视觉样式 - channel C1 使用蓝色的圆圈来表示，channel C2 使用红色的连接线表示：

![network.channel2](./network.diagram.10.png)

*一个为 R2 和 R3 的新的 channel C2 使用联盟定义 X2 创建出来。这个 channel 具有一个 channel configuration CC2，完全地同 network configuration NC4 以及 channel configuration CC1 分离开来。Channel C2 由 R2 和 R3 来管理，他们两个就像 CC2 中的一个 policy 定义的那样具有相同的权利。R1 和 R4 在 CC2 中是没有任何权利的。*

Channel C2 为联盟 X2 提供了一个私有的通信机制。同样，需要注意到的是所有组织如何联结到一个联盟中就是如何形成一个 channel。Channel configuration CC2 现在包含了规约来管理 channel 的资源，通过 channel C2 来向组织分配管理权限。这被 R2 和 R3 唯一地进行管理，R1 和 R4 在 channel C2 中是没有权力的。比如 channel configuration CC2 可以后续地被更新添加新的组织来支持网络的成长，但是这个只能由 R2 或者 R3 来完成。

要注意的是 channel configuration CC1 和 CC2 是如何彼此完全分离的，以及如何同 network configuration NC4 是如何完全分离的。我们也看到了一个 Hyperledger Fabric 网络的去中心化的特质，一旦 channel C2 被创建后，它是由组织 R2 和 R3 来独立管理的。Channel 的规约通常是保持彼此分离的，并且只能由 channel 中的授权的组织来进行改动。

随着网络和 channels 的发展，网络和 channel 的配置也会升级。这里有一个能够以可控的形式实现这些的流程 - 引入能够保留对于这些配置的改动的配置交易。每次配置的改变会生成一个新的配置区块交易，在[后边的话题中](#the-ordering-serivce)，我们会看到这些区块是如何被验证并接受的，来对应生成一个更新的网络及 channel 的配置。

### 网络和 channel 配置

在我们的样例网络中，我们看到了网络和 channel 配置的重要性。这些配置很重要，是因为他们封装了由网络成员同意的**策略**，这提供了一个关于控制对网络资源访问的一个共享的参考。网络和 channel 配置也包含了有关网络和 channel 共同组合的一些**事实**，比如联盟的名字以及它所包含的组织。

比如，当使用排序服务节点 O4 首次形成网络的时候，它的行为是由网络配置 NC4 来管理的。NC4 的初始配置中只包含了允许组织 R4 来管理网络资源的策略。NC4 接下来被变更为同样允许 R1 来管理网络资源。一旦这个改动生效后，任何来自于组织 R1 或者 R4 的管理员并连接到 O4 的话将会具有网络管理的权限，因为这就是网络配置 NC4 中的策略所允许的。在内部来说，在排序服务中的每个节点记录着网络配置中的每个 channel，所以在网络级别中每个被创建的 channel 都会有一条记录。

这就意味着，尽管排序服务节点 O4 是创建联盟 X1 和 X2 以及 channel C1 和 C2 的角色，网络配置 NC4 中包含了 O4 所遵守的这个网络的**智能**。只要 O4 表现为是一个好的角色，并且在它处理网络资源的任何时候都能够正确的实现在 NC4 中定义的策略的话，那么我们的网络就会想所有的组织所共同统一的那样进行工作。在很多方面 NC4 被认为要比 O4 更重要，因为最终是它来管控着网络的访问。

与 peers 同样的概念也可以应用到 channel 配置。在我们的网络中，P1 和 P2 是很类似的角色。当 Peer 节点 P1 和 P2 同客户端应用程序 Ap 或者 A2 进行交互的时候，他们使用了在 channel 配置中定义的策略来管理对 channel C1 资源的访问。

比如，如果 A1 想要访问在 peer 节点 P1 或者 P2 上的智能合约 chaincode S5 的话，每个 peer 节点会使用它的 CC1 的副本来决定 A1 能够进行哪些操作。比如根据在 CC1 中定义的策略，A1 可能被允许从账本 L1 上读取或者写入数据。之后我们会看到在 channel 和它的 channel 配置 CC2 中对于操作者的相同的模式。我们能够看到尽管 peers 和应用程序在网络中是关键的操作者，他们在一个 channel 中的行为更多的是由 channel 配置的策略来决定的。

最后，理解网络和 channel 配置是如何在物理上来实现的是非常重要的。我们能够看到网络和 channel 配置在逻辑上是单一的 - 对于网络会有一个，对于每个 channel 也会有一个。这一点非常重要，任何访问网络或者 channel 的组件必须要有一个共享的对于授予给不同组织的权限的理解。

尽管在逻辑上这是一个单一的配置，它实际上被复制并且由形成网络或者 channel 的每个节点来保持一致的。比如，在我们的网络中，peer 节点 P1 和 P2 都有 channel 配置 CC1 的一个副本，在这个网络完全完成的时候，peer 节点 P2 和 P3 也会有 channel 配置 CC2 的一个副本。类似的，排序服务节点 O4 具有网络配置的一个副本，但是在一个[多节点配置](#the-ordering-service)中，每个排序服务节点将会有他们自己的关于网络配置的副本。

网络和 channel 的配置使用了同用户交易所使用的相同的区块链技术来保持一致 -- 但是是对于 **配置** 的交易。想要改变一个网络或者 channel 的配置，一个管理员必须要提交一个配置交易来改变网络或者 channel 的配置。它必须要被在合适的策略中指定的组织来提供签名，这些组织对于配置的变更有责任。这个策略被称为 **mod_policy** 我们会[在稍后讨论](#changing-policy)。

实际上，排序服务节点运行着一个小型的区块链，通过我们前边提到过的 **系统 channel** 连接。使用系统 channel 排序服务节点分发着网络配置交易。这些交易被用来协同维护在每个排序服务节点间的网络配置副本的一致的副本。通过类似的方式，在一个 **应用程序 channel** 中的 peer 节点可以分发 channel 配置交易。类似的，这些交易被用来维护在每个 peer 节点上具有 channel 配置的一个一致性的副本。

这种在逻辑上独立的对象，但却被物理地分发的平衡，在 Hyperledger Fabric 中是一种常见的模式。像网络配置这样的对象，逻辑上是单独的，但却在一些排序服务节点间被物理复制。对于 channel 配置，账本以及一些智能合约，我们也看到了这样的情况，他们被安装在了多个地方，但是他们的接口其实是逻辑存在于 channel 级别上的。这种模式你会在 Hyperledger Fabric 中重复地看到多次，这使 Hyperledger Fabric 变得既去中心化，并且还能够在同一时间进行管理。

## 添加另外一个 peer

现在组织 R3 能够完全地参与到 channel C2 中了，让我们来把它的基础设施组件添加到 channel 中。我们不会每次只加一个组件，我们将会一次性地添加一个 peer，它的一个账本的本地副本，一个智能合约以及一个客户端应用程序。

让我们看一下带有被添加了组件的组织 R3 的网络是什么样：

![network.peer2](./network.diagram.11.png)

*这个图标展示了在网络 N 中关于 channel C1 和 C2 的一下事实：客户端应用程序 A1 和 A2 可以使用 channel C1 来同 peer P1 和 P2，以及排序服务 O4 进行通信。客户端应用程序 A3 能够使用 C2 同 peer P3 和排序服务 O4 进行通信。排序服务 O4 可以使用 channel C1 和 C2 的通信服务。Channel 配置 CC1 应用到了 channel C1 上，CC2 应用到了 channel C2 上。*

首先，要注意的是因为 peer 节点 P3 连接到了 channel C2，它具有一个 **不同的** 账本 -- L2 -- 同其他的使用 channel C1 的 peer 节点。账本 L2 有效地控制在了 channel C1 中。账本 L1 是完全分离的，它被限制在了 channel C1。这么做是有意义的 -- channel C2 的目的是为联盟 X2 的成员间提供私有通信，并且账本 L2 是他们的交易的一个私有存储。

同样的方式，智能合约 S6，在 peer 节点 P3 上被安装，在 channel C2 上被定义，被用来为账本 L2 提供一个可控的访问。应用程序 A3 现在能够使用 channel C2 来调用智能合约 S6 提供的服务来生成交易，这些交易会在网络中被每个账本的副本所接受。

到目前为止，我们有一个独立的网络，其中定义了具有两个完全分离的 channel。这两个 channel 提供了对于组织来讲是独立管理的设施来彼此进行交互。这是在工作中的去中心化，我们在管控和自制之间具有着一个平衡。这个是通过应用到 channels 的策略来实现的，这些 channels 是由不同的组织来控制而且这些 channels 又会影响这些组织。

## 把一个 peer 添加到多个 channels 中

在这个网络开发的最后一个阶段，让我们把关注点在转回到组织 R2。我们可以通过把 R2 加入到多个 channels 中的方式来让它成为两个联盟 X1 和 X2 的成员。

![network.multichannel](./network.diagram.12.png)

*这个图表展示了在网络 N 中关于 channel C1 和 C2 的一下事实：客户端应用程序 A1 能够使用 channel C1 同 peers P1 和 P2 以及 排序服务 O4 进行通信。客户端应用程序 A2 可以使用 channel C1 同 peers P1 和 P2 进行通信，可以使用 channel C2 同 peers P2 和 P3 以及排序服务 O4 进行通信。客户端应用程序 A3 能够使用 channel C2 同 peer P3 和 P2 和排序服务 O4 进行通信。排序服务 O4 能够使用 channel C1 和 C2 的通信服务。Channel 配置CC1 应用在了 channel C1 中，CC2 应用在了 channel C2 中。*

我们能够看到，R2 在网络中是一个特别的组织，因为它是唯一的一个同时属于两个 channels 的成员的组织！它能够在 channel C1 上跟组织 R1 进行交易，也能够同时使用另外一个不同的 channel C2 来跟组织 R3 进行交易。

注意 peer 节点 P2 是如何将智能合约 S5 安装在 channel C1 中，将智能合约 S6 安装在 channel C2 中。Peer 节点 P2 同时是两个 channels 的成员，并且通过不同的智能合约来处理不同的账本。

这是一个非常强大的概念 -- channels 既提供了组织间的分离，又提供了一个组织间进行合作的机制。总的来说，这个基础设施是由一系列的独立的组织来提供的，并且在这些组织间进行共享。

注意到基于 channel， peer 节点 P2 进行交易的地方，P2 的行为基于这个 channel的管控是非常不同的也是很重要的。特别的是，在 channel 配置 CC1 中包含的策略说明了当 P2 在 channel C1 中进行交易的时候，这些操作都是可用的，这也是在 channel 配置 CC2 中的策略来控制在 channel C2 中的 P2 的行为。

这就是这样设计的 -- R2 和 R1 同意了对于 channel C1 的规则，R2 和 R3 同意了对于 channel C2 的规则。这些规则被对应的 channel 策略所捕获 -- 他们能够并且必须要在一个 channel 里被使用来强制正确的行为，就像当初同意的一样。

类似的，我们额能够看到客户端应用程序 A2 现在能够在 channel C1 和 C2 上进行交易。并且类似的，它也会按照在相关的 channel 配置中的策略来进行管理。另外，注意客户端应用程序 A2 和 peer 节点 P2 在使用者一个混合的视觉词汇表 -- 既包括先也包括连接点。你能够看到他们是一样的，他们在视觉上是一样的。

### 排序服务

善于观察的读者可能已经注意到排序服务看起来像是一个中心化的组件，它最初被用来创建这个网络，然后连接到了网络中的每个 channel。即使我们添加了 R1 和 R4 到了管理排序服务的网络配置策略 NC4，这个排序节点依旧是运行在 R4 的基础设施上。在一个去中心化的世界中，这个看起来是错误的！

不必担心！我们的样例网络显示的是一个最简单的排序服务配置，为了帮助你从一个网络管理员的角度来理解。事实上，排序服务本身可以是完全的去中心化的！我们之前提到过一个排序服务可以包含很多单独的由不同组织所有的节点，让我们看一下在我们的网络中应该怎么做。

让我们看一个更加真实的排序服务节点配置：

![network.finalnetwork2](./network.diagram.15.png)

*一个多组织的排序服务。排序服务包括排序服务节点 O1 和 O4。O1 是由组织 R1 提供的，O4 是由组织 R4 提供的。网络配置 NC4 中定义了对于来自于R1 和 R4 的操作者的网络资源权限。*

我们能够看到这个排序服务是完全去中心化的 -- 它在组织 R1 和 R4 中运行。网络配置策略 NC4 赋予了 R1 和 R4 对于网络资源相同的权限。R1 和 R4 的客户端应用程序和 peer 节点可以通过连接节点 O1 或者 O4 来管理网络资源，就像在网络配置 NC4 中定义的策略一样，两个节点是用同一种方式来操作的。在实际中，来自于一个组织的操作者 *想要* 使用它们自己组织提供的基础设施，但是那个显然并不总是这样的。

### 去中心化的交易分发

跟作为一个网络的管理点一样，排序服务同样提供了另外一个关键的设施 -- 它是交易的分发点。排序服务是一个从应用程序搜集经过背书过的交易的组件，然后它会把这些交易进行排序并放进交易区块中，这些区块会被分发到 channel 中的每个 peer 节点。在每个这样的提交节点中，交易被记录下来，不管是有效的还是无效的，并且他们本地的账本副本也会更新。

注意到对于 channel C1 和网络 N，排序服务节点 O4 是如何在扮演着不同的角色。当在 channel 级别操作时，O4 的角色是搜集交易并在 channel 中分发区块。它依据 channel 配置 CC1 重定义的策略来操作。当在网络级别操作时，O4 的角色是提供一个对于网络资源的管理操作，这个是根据网络配置 NC4 中定义的策略来操作的。我们应该注意这些不同的角色是如何在 channel 和网络的配置中定义的。这个应该让你对于在 Hyperledger Fabric 中基于配置的可声明的策略的重要性加强了印象。两种策略都被一定并且用来管控经过联盟中的每个成员同意过的行为。

我们能够看到这个排序服务，像 Hyperledger Fabric 中的其他组件一样，是一个完全去中心化的组件。不管是作为一个网络的管理点，还是作为一个 channel 中的分发节点，它的节点可以依据在一个网络中的多个组织的要求被分散地运行。

### 修改策略

经过我们对于这个样例网络的解析，我们看到了在这个系统中使用策略对于不同操作者行为的控制的重要性。我们仅仅讨论了一些可用的策略，但是这里还有很多可声明的对于管控行为的不同方面的所定义的策略。这些单独的策略会在文档的其他部分讨论。

最重要的一点，Hyperledger Fabric 提供了一个独特的有效策略来允许网络和 channel 管理员自己来管理策略的变更！底层的理论是策略的变更是一个常量，无论它是发生在不同的组织间，还是由外部的监管者加进来的。比如一个新的组织想要加入一个 channel 或者一些已经存在的组织想要增加或减少他们的权限。让我们来详细的看一下在 Hyperledger Fabric 中修改策略是如何实现的。

理解这个的一个关键点是一个策略的变化是由在策略本身的有一个策略来管理的。那就是 **修改策略**，或者简短的 **mod_poicy**，它是在一个管理变化的网络或者 channel 配置中的头等策略。关于我们是如何 **已经** 使用了 mod_policy 来管理在我们的网络中的变化，让我们提供两个简单的事例。

第一个例子是当网络初始地被创建的时候。在那个时候，只有组织 R4 被允许管理网络。在实际当中，这个是通过在网络配置 NC4 中把 R4 定义为唯一一个有权限来管理网络资源的组织。并且对于 NC4 的 mod_policy 也仅仅提到了组织 R4 -- 只有 R4 被允许改变这个配置。

我们接下来将网络 N 进行了演进，同时允许组织 R1 来管理网络。R4 通过将 R1 添加到对于 channel 创建和联盟创建的策略中实现了这个。因为这个改动，R1 就可以定义联盟 X1 和 X2 了，并且可以创建 channels C1 和 C2。R1 在网络配置中对于 channel 和联盟策略具有了同样的管理权限。

R4 甚至可以通过网络配置来给 R1 赋予更大的权限！R4 可以将 R1 添加到 mod_poicy，这样 R1 就同样可以管理这个网络中的变更了。

第二个权利要比第一个权利大的多，因为现在 R1 具有了在网络配置 NC4 上的 **所有管控**！这意味着，R1 能够移除 R4 在这个网络的管理权限。在实际当中，R4 会将 mod_policy 配置成对于这样的改动需要 R4 来进行批准，或者需要所有的咋 mod_policy 中定义的组织批准。这里有很大的灵活性来使 mod_policy 根据它的需要进行负责的定义来满足任何的流程的需要。

这就是在实际工作中的 mod_policy -- 它允许一个基本的配置被优雅地演进为一个复杂的配置。这些演进永远都是需要所有被引入的组织的同意。mod_policy 像在一个网络或者 channel 配置中的每一个其他的策略一样，它定义了一系列的组织，这些组织被允许自己来修改这个 mod_policy。

我们仅仅在这个部分了解了策略以及 mod_policy 的表面的内容。这会在策略的话题中有更详细的讨论，但是现在让我们回到这个已经完成的网络！

## 网路已经完全形成了

让我们使用一个统一的视觉词典来回顾一下我们的网络应该是什么样。我们使用我们的更加紧凑的视觉语法来稍微重新组织一下这个网络，因为它能够更好地适应更大的一个拓扑结构：

![network.finalnetwork2](./network.diagram.14.png)

*在这个图表中，我们看到了这个 Fabric 区块链网络包括了两个应用程序 channels 以及一个排序 channel。组织 R1 和 R4 负责排序 channel，R1 和 R2 负责蓝色的应用程序 channel，R2 和 R3 负责红色的应用程序 channel。客户端应用程序 A1 是组织 R1 的一个元素，CA1 是它的证书认证机构。注意到组织 R2 的 peer P2可以使用蓝色的通信设施，也可以使用红色的应用程序 channel。每个应用程序 channel 具有它自己的 channel 配置，这里是 CC1 和 CC2。系统 channel 的 channel 配置是网络配置 NC4 的一部分。*

我们已经在我们在概念上构建一个 Hyperledger Fabric 区块链网络事例的最后一部分了。我们创建了一个有四个组织的网络，带有两个 channels 和三个 peer 节点，两个智能合约和一个排序服务。这个由四个证书认证机构来支持的。它为三个客户端应用程序提供了账本及智能合约服务，这些应用程序可以通过两个 channels 与账本和智能合约进行交互。花些时间来仔细看看这个图表中的网络的详细内容，并且随时回来阅读这个部分来加强你的知识，或者查看其它更详细的话题。

### 网络组件的总结

下边是我们讨论过的网络组件的一个快速总结：

* [账本](../glossary.html#ledger). 每个 channel 一个，由
  [区块链](../glossary.html#block) 和 [World state](../glossary.html#world-state) 组成
* [智能合约](../glossary.html#smart-contract) (或者叫 chaincode)
* [Peer 节点](../glossary.html#peer)
* [排序服务](../glossary.html#ordering-service)
* [Channel](../glossary.html#channel)
* [证书认证机构](../glossary.html#hyperledger-fabric-ca)

## 网络总结

在这个话题中，我们看到了不同的组织间是如何共享他们的基础设施来提供一个集成的 Hyperledger Fabric 区块链网络。我们看到了这个集体的基础设施是如何被组织到 channels 中来提供可以独立管理的私有通信机制。我们也看到了像客户端应用程序、管理员、peers 和排序节点这些操作者们是如何通过由不同的组织对应的证书认证机构颁发的证书被识别出来。我们也看到了对于网络和 channel 资源，定义这些组织的操作者们具有的经过同意的权限的策略的重要性。
