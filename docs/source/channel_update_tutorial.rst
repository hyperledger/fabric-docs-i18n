Adding an Org to a Channel - 向通道添加组织
==========================

.. note:: Ensure that you have downloaded the appropriate images and binaries
          as outlined in :doc:`install` and :doc:`prereqs` that conform to the
          version of this documentation (which can be found at the bottom of the
          table of contents to the left). In particular, your version of the
          ``fabric-samples`` folder must include the ``eyfn.sh`` ("Extending
          Your First Network") script and its related scripts.

          确保你已经下载了 :doc:`install` 和 :doc:`prereqs` 中所罗列的和本文版
          本左边内容列表的底部可以查看）一致的镜像和二进制。特别注意，在你的版
          本中，``fabric-samples`` 文件夹必须包含 ``eyfn.sh`` （ “Extending 
          Your First Network” ）脚本以及和它相关的脚本。

This tutorial serves as an extension to the :doc:`build_network` (BYFN) tutorial,
and will demonstrate the addition of a new organization -- ``Org3`` -- to the
application channel (``mychannel``) autogenerated by BYFN. It assumes a strong
understanding of BYFN, including the usage and functionality of the aforementioned
utilities.

本教程是 :doc:`build_network` （ BYFN ） 教程的扩展，将演示一个由 BYFN 自动生成的新
的组织 -- ``Org3`` -- 加入到应用通道 （ ``mychannel`` ） 的过程。本教程假设你对 BYFN 
有很好地理解，包括用法以及上面提及的工具的功能。

While we will focus solely on the integration of a new organization here, the same
approach can be adopted when performing other channel configuration updates (updating
modification policies or altering batch size, for example). To learn more about the
process and possibilities of channel config updates in general, check out
:doc:`config_update`). It's also worth noting that channel configuration updates like
the one demonstrated here will usually be the responsibility of an organization admin
(rather than a chaincode or application developer).

虽然我们在这里将只关注新组织的集成，但执行其他通道配置更新（如更新修改策略，调整块大小）
也可以采取相同的方式。要了解更多的通道配置更新的相关过程，请查看 :doc:`config_update` 。
值得注意的是，像本文演示的这些通道配置更新通常是组织管理者（而非链码或者应用开发者）的
职责。

.. note:: Make sure the automated ``byfn.sh`` script runs without error on
          your machine before continuing. If you have exported your binaries and
          the related tools (``cryptogen``, ``configtxgen``, etc) into your PATH
          variable, you'll be able to modify the commands accordingly without
          passing the fully qualified path.

          在继续本文前先确保自动化脚本 ``byfn.sh`` 运行无误。如果你已经把你的二进
          制文件和相关工具(如 ``cryptogen``，``configtxgen`` 等）放在了 PATH 变量
          指定的路径下，你可以修改相应的命令而不使用全路径。

Setup the Environment - 环境构建
~~~~~~~~~~~~~~~~~~~~~

We will be operating from the root of the ``first-network`` subdirectory within
your local clone of ``fabric-samples``. Change into that directory now. You will
also want to open a few extra terminals for ease of use.

你将从你克隆到本地的 ``fabric-samples`` 的子目录 ``first-network`` 进行操作。现在，
进入那个目录。你还要打开一些额外的终端窗口以便于使用。

First, use the ``byfn.sh`` script to tidy up. This command will kill any active
or stale docker containers and remove previously generated artifacts. It is by no
means **necessary** to bring down a Fabric network in order to perform channel
configuration update tasks. However, for the sake of this tutorial, we want to operate
from a known initial state. Therefore let's run the following command to clean up any
previous environments:

首先，使用 ``byfn.sh`` 脚本清理环境。这个命令会清除运行、终止状态的容器，并且移除之前
生成的构件。关闭 Fabric 网络并非执行通道配置升级的 **必要** 步骤。但是为了本教程，我们
希望从一个已知的初始状态开始，因此让我们运行以下命令来清理之前的环境：

.. code:: bash

  ./byfn.sh down

Now generate the default BYFN artifacts:

现在生成默认的 BYFN 构件：

.. code:: bash

  ./byfn.sh generate

And launch the network making use of the scripted execution within the CLI container:

启动网络，并执行 CLI 容器内的脚本：

.. code:: bash

  ./byfn.sh up

Now that you have a clean version of BYFN running on your machine, you have two
different paths you can pursue. First, we offer a fully commented script that will
carry out a config transaction update to bring Org3 into the network.

现在你的机器上运行着一个干净的 BYFN 版本，你有两种不同的方式可选。第一种，我们提供
了一个有很好注释的脚本，来执行把 Org3 加入网络的配置交易更新。

Also, we will show a "manual" version of the same process, showing each step
and explaining what it accomplishes (since we show you how to bring down your
network before this manual process, you could also run the script and then look at
each step).

我们也提供同样过程的“手动”版本，演示每一个步骤并解释它完成了什么（我们在之前演示了
如何停止你的网络，你可以先运行那个脚本，然后再来看每个步骤）。

Bring Org3 into the Channel with the Script - 使用脚本将 Org3 加入通道
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You should be in ``first-network``. To use the script, simply issue the following:

在 ``first-network`` 目录下，简单地执行以下命令来使用脚本：

.. code:: bash

  ./eyfn.sh up

The output here is well worth reading. You'll see the Org3 crypto material being
added, the config update being created and signed, and then chaincode being installed
to allow Org3 to execute ledger queries.

此处的输出值得一读。你可以看到添加了 Org3 的加密材料，配置更新被创建和签名，然后安装
链码， Org3 就可以执行账本查询了。

If everything goes well, you'll get this message:

如果一切顺利，你会看到以下信息：

.. code:: bash

  ========= All GOOD, EYFN test execution completed ===========

``eyfn.sh`` can be used with the same Node.js chaincode and database options
as ``byfn.sh`` by issuing the following (instead of ``./byfn.sh up``):

``eyfn.sh`` 可以像 ``byfn.sh`` 一样使用 Node.js 链码和数据库选项，如下所示
（替代 ``./byfn.sh up`` ）：

.. code:: bash

  ./byfn.sh up -c testchannel -s couchdb -l node

And then:

然后：

.. code:: bash

  ./eyfn.sh up -c testchannel -s couchdb -l node

For those who want to take a closer look at this process, the rest of the doc will
show you each command for making a channel update and what it does.

对于想要详细了解该过程的人，文档的剩余部分会为你展示通道升级的每个命令，以及命令的
作用。

Bring Org3 into the Channel Manually - 手动将 Org3 添加到通道
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. note:: The manual steps outlined below assume that the ``FABRIC_LOGGING_SPEC``
          in the ``cli`` and ``Org3cli`` containers is set to ``DEBUG``.

          下面的步骤均假设 ``CORE_LOGGING_LEVEL`` 变量在 ``cli`` 和 ``Org3cli`` 
          容器中设置为 ``DEBUG`` 。

          For the ``cli`` container, you can set this by modifying the
          ``docker-compose-cli.yaml`` file in the ``first-network`` directory.
          e.g.

          对于 ``cli`` 容器，你可以通过修改 ``first-network`` 目录下的
          ``docker-compose-cli.yaml`` 文件来配置。例如：

          .. code::

            cli:
              container_name: cli
              image: hyperledger/fabric-tools:$IMAGE_TAG
              tty: true
              stdin_open: true
              environment:
                - GOPATH=/opt/gopath
                - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
                #- FABRIC_LOGGING_SPEC=INFO
                - FABRIC_LOGGING_SPEC=DEBUG

          For the ``Org3cli`` container, you can set this by modifying the
          ``docker-compose-org3.yaml`` file in the ``first-network`` directory.
          e.g.

          对于 ``Org3cli`` 容器，你可以通过修改 ``first-network`` 目录下的 
          ``docker-compose-org3.yaml`` 文件来配置。例如：

          .. code::

            Org3cli:
              container_name: Org3cli
              image: hyperledger/fabric-tools:$IMAGE_TAG
              tty: true
              stdin_open: true
              environment:
                - GOPATH=/opt/gopath
                - CORE_VM_ENDPOINT=unix:///host/var/run/docker.sock
                #- FABRIC_LOGGING_SPEC=INFO
                - FABRIC_LOGGING_SPEC=DEBUG

If you've used the ``eyfn.sh`` script, you'll need to bring your network down.
This can be done by issuing:

如果你已经使用了 ``eyfn.sh`` 脚本，你需要先关闭你的网络。通过如下所示命令来完成：

.. code:: bash

  ./eyfn.sh down

This will bring down the network, delete all the containers and undo what we've
done to add Org3.

这会关闭网络，删除所有的容器，并且撤销我们添加 Org3 的操作。

When the network is down, bring it back up again.

当网络停止后，再次将它启动起来。

.. code:: bash

  ./byfn.sh generate

Then:

然后：

.. code:: bash

  ./byfn.sh up

This will bring your network back to the same state it was in before you executed
the ``eyfn.sh`` script.

这会将你的网络恢复到你执行 ``eyfn.sh`` 脚本之前的状态。

Now we're ready to add Org3 manually. As a first step, we'll need to generate Org3's
crypto material.

现在我们可以手动添加 Org3 了。第一步，我们需要生成 Org3 的加密材料。

Generate the Org3 Crypto Material - 生成 Org3 加密材料
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In another terminal, change into the ``org3-artifacts`` subdirectory from
``first-network``.

在另一个终端，切换到 ``first-network`` 的子目录 ``org3-artifacts`` 中。

.. code:: bash

  cd org3-artifacts

There are two ``yaml`` files of interest here: ``org3-crypto.yaml`` and ``configtx.yaml``.
First, generate the crypto material for Org3:

这里需要关注两个 ``yaml`` 文件： ``org3-crypto.yaml`` 和 ``configtx.yaml`` 。首先，
生成 Org3 的加密材料：

.. code:: bash

  ../../bin/cryptogen generate --config=./org3-crypto.yaml

This command reads in our new crypto ``yaml`` file -- ``org3-crypto.yaml`` -- and
leverages ``cryptogen`` to generate the keys and certificates for an Org3
CA as well as two peers bound to this new Org. As with the BYFN implementation,
this crypto material is put into a newly generated ``crypto-config`` folder
within the present working directory (in our case, ``org3-artifacts``).

该命令读取我们新的加密配置的 ``yaml`` 文件 -- ``org3-crypto.yaml`` -- 然后调用
``cryptogen`` 来为 Org3 CA 和其他两个绑定到这个新组织的节点生成秘钥和证书。就像 
BYFN 实现的，加密材料放到当前目录新生成的 ``crypto-config`` 文件夹下（在我们例子
中是 ``org3-artifacts`` ）。

Now use the ``configtxgen`` utility to print out the Org3-specific configuration
material in JSON. We will preface the command by telling the tool to look in the
current directory for the ``configtx.yaml`` file that it needs to ingest.

现在使用 ``configtxgen`` 工具以 JSON 格式打印出 Org3 对应的配置材料。我们将在执
行命令时告诉这个工具去获取当前目录的 ``configtx.yaml`` 文件。

.. code:: bash

    export FABRIC_CFG_PATH=$PWD && ../../bin/configtxgen -printOrg Org3MSP > ../channel-artifacts/org3.json

The above command creates a JSON file -- ``org3.json`` -- and outputs it into the
``channel-artifacts`` subdirectory at the root of ``first-network``. This
file contains the policy definitions for Org3, as well as three important certificates
presented in base 64 format: the admin user certificate (which will be needed to act as
the admin of Org3 later on), a CA root cert, and a TLS root cert. In an upcoming step we
will append this JSON file to the channel configuration.

上面的命令会创建一个 JSON 文件 -- ``org3.json`` -- 并把文件输出到 ``first-network`` 
的 ``channel-artifacts`` 子目录下。这个文件包含了 Org3 的策略定义，还有三个 base 64 
格式的重要的证书：管理员用户证书（之后作为 Org3 的管理员角色），一个根证书，一个 TLS 
根证书。之后的步骤我们会将这个 JSON 文件追加到通道配置。

Our final piece of housekeeping is to port the Orderer Org's MSP material into
the Org3 ``crypto-config`` directory. In particular, we are concerned with the
Orderer's TLS root cert, which will allow for secure communication between
Org3 entities and the network's ordering node.

我们最后的工作是拷贝排序节点的 MSP 材料到 Org3 的 ``crypto-config`` 目录下。我们
尤其关注排序节点的 TLS 根证书，它可以用于 Org3 的节点和网络的排序节点间的安全通信。

.. code:: bash

  cd ../ && cp -r crypto-config/ordererOrganizations org3-artifacts/crypto-config/

Now we're ready to update the channel configuration...

现在我们准备开始升级通道配置。

Prepare the CLI Environment - 准备 CLI 环境
~~~~~~~~~~~~~~~~~~~~~~~~~~~

The update process makes use of the configuration translator tool -- ``configtxlator``.
This tool provides a stateless REST API independent of the SDK. Additionally it
provides a CLI, to simplify configuration tasks in Fabric networks. The tool allows
for the easy conversion between different equivalent data representations/formats
(in this case, between protobufs and JSON). Additionally, the tool can compute a
configuration update transaction based on the differences between two channel
configurations.

更新的步骤需要用到配置转换工具 -- ``configtxlator`` 。这个工具提供了独立于 SDK 的
无状态 REST API。它还额外提供了 CLI，用于简化 Fabric 网络中的配置任务。这个工具对
不同的数据表示或格式间的转化提供了便利的功能（在这个例子中就是 protobufs 和 JSON 
格式的互转）。另外，这个工具能基于两个不同的通道配置计算出配置更新交易。

First, exec into the CLI container. Recall that this container has been
mounted with the BYFN ``crypto-config`` library, giving us access to the MSP material
for the two original peer organizations and the Orderer Org. The bootstrapped
identity is the Org1 admin user, meaning that any steps where we want to act as
Org2 will require the export of MSP-specific environment variables.

首先，进入到 CLI 容器。这个容器挂载了 BYFN 的 ``crypto-config`` 目录，允许我们访问之
前两个节点组作织和排序组织的 MSP 材料。默认的身份是 Org1 的管理员用户，所以如果我们
想作为 Org2 进行任何操作，需要设置和 MSP 相关的环境变量。

.. code:: bash

  docker exec -it cli bash

Export the ``ORDERER_CA`` and ``CHANNEL_NAME`` variables:

设置 ``ORDERER_CA`` 和 ``CHANNEL_NAME`` 变量：

.. code:: bash

  export ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem  && export CHANNEL_NAME=mychannel

Check to make sure the variables have been properly set:

检查并确保环境变量已正确设置：

.. code:: bash

  echo $ORDERER_CA && echo $CHANNEL_NAME

.. note:: If for any reason you need to restart the CLI container, you will also need to
          re-export the two environment variables -- ``ORDERER_CA`` and ``CHANNEL_NAME``.

          如果需要重启 CLI 容器，你需要重新设置 ``ORDERER_CA`` 和 ``CHANNEL_NAME`` 这两个
          环境变量。

Fetch the Configuration - 获取配置
~~~~~~~~~~~~~~~~~~~~~~~

Now we have a CLI container with our two key environment variables -- ``ORDERER_CA``
and ``CHANNEL_NAME`` exported.  Let's go fetch the most recent config block for the
channel -- ``mychannel``.

现在我们有了一个设置了 ``ORDERER_CA`` 和 ``CHANNEL_NAME`` 环境变量的 CLI 容器。让我们
获取通道 ``mychannel`` 的最新的配置区块。

The reason why we have to pull the latest version of the config is because channel
config elements are versioned. Versioning is important for several reasons. It prevents
config changes from being repeated or replayed (for instance, reverting to a channel config
with old CRLs would represent a security risk). Also it helps ensure concurrency (if you
want to remove an Org from your channel, for example, after a new Org has been added,
versioning will help prevent you from removing both Orgs, instead of just the Org you want
to remove).

我们必须拉取最新版本配置的原因是通道配置元素是版本化的。版本管理由于一些原因显得很重要。
它可以防止通道配置更新被重复或者重放攻击（例如，回退到带有旧的 CRLs 的通道配置将会产生
安全风险）。同时它保证了并行性（例如，如果你想从你的通道中添加新的组织后，再删除一个组
织 ，版本管理可以帮助你移除想移除的那个组织，并防止移除两个组织）。

.. code:: bash

  peer channel fetch config config_block.pb -o orderer.example.com:7050 -c $CHANNEL_NAME --tls --cafile $ORDERER_CA

This command saves the binary protobuf channel configuration block to
``config_block.pb``. Note that the choice of name and file extension is arbitrary.
However, following a convention which identifies both the type of object being
represented and its encoding (protobuf or JSON) is recommended.

这个命令将通道配置区块以二进制 protobuf 形式保存在 ``config_block.pb`` 。注意文件的
名字和扩展名可以任意指定。然而，为了便于识别，我们建议根据区块存储对象的类型和编码格
式（ protobuf 或 JSON ）进行命名。

When you issued the ``peer channel fetch`` command, there was a decent amount of
output in the terminal. The last line in the logs is of interest:

当你执行 ``peer channel fetch`` 命令后，在终端上会有相当数量的打印输出。日志的最后一
行比较有意思：

.. code:: bash

  2017-11-07 17:17:57.383 UTC [channelCmd] readBlock -> DEBU 011 Received block: 2

This is telling us that the most recent configuration block for ``mychannel`` is
actually block 2, **NOT** the genesis block. By default, the ``peer channel fetch config``
command returns the most **recent** configuration block for the targeted channel, which
in this case is the third block. This is because the BYFN script defined anchor
peers for our two organizations -- ``Org1`` and ``Org2`` -- in two separate channel update
transactions.

这是告诉我们最新的 ``mychannel`` 的配置区块实际上是区块 2， **并非** 初始区块。 ``peer 
channel fetch config`` 命令默认返回目标通道最新的配置区块，在这个例子里是第三个区块。
这是因为 BYFN 脚本分别在两个不同通道更新交易中为两个组织 -- ``Org1`` 和 ``Org2`` -- 定
义了锚节点。

As a result, we have the following configuration sequence:

最终，我们有如下的配置块序列：

  * block 0: genesis block
  * block 1: Org1 anchor peer update
  * block 2: Org2 anchor peer update

Convert the Configuration to JSON and Trim It Down - 将配置转换到 JSON 格式并裁剪
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Now we will make use of the ``configtxlator`` tool to decode this channel
configuration block into JSON format (which can be read and modified by humans).
We also must strip away all of the headers, metadata, creator signatures, and
so on that are irrelevant to the change we want to make. We accomplish this by
means of the ``jq`` tool:

现在我们用 ``configtxlator`` 工具将这个通道配置解码为 JSON 格式（以便友好地被阅读
和修改）。我们也必须裁剪所有的头部、元数据、创建者签名等和我们将要做的修改无关的内
容。我们通过 ``jq`` 这个工具来完成裁剪：

.. code:: bash

  configtxlator proto_decode --input config_block.pb --type common.Block | jq .data.data[0].payload.data.config > config.json

This leaves us with a trimmed down JSON object -- ``config.json``, located in
the ``fabric-samples`` folder inside ``first-network`` -- which
will serve as the baseline for our config update.

我们得到一个裁剪后的 JSON 对象 -- ``config.json`` ，放置在 ``fabric-samples`` 
下的 ``first-network`` 文件夹中 -- ``first-network`` 是我们配置更新的基准工作
目录。

Take a moment to open this file inside your text editor of choice (or in your
browser). Even after you're done with this tutorial, it will be worth studying it
as it reveals the underlying configuration structure and the other kind of channel
updates that can be made. We discuss them in more detail in :doc:`config_update`.

花一些时间用你的文本编辑器（或者你的浏览器）打开这个文件。即使你已经完成了这个教程，
也值得研究下它，因为它揭示了底层配置结构，和能做的其它类型的通道更新升级。我们将在
:doc:`config_update` 更详细地讨论。

Add the Org3 Crypto Material - 添加Org3加密材料
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. note:: The steps you've taken up to this point will be nearly identical no matter
          what kind of config update you're trying to make. We've chosen to add an
          org with this tutorial because it's one of the most complex channel
          configuration updates you can attempt.

          目前到这里你做的步骤和其他任何类型的配置升级所需步骤几乎是一致的。我们之
          所以选择在教程中添加一个组织，是因为这是能做的配置升级里最复杂的一个。

We'll use the ``jq`` tool once more to append the Org3 configuration definition
-- ``org3.json`` -- to the channel's application groups field, and name the output
-- ``modified_config.json``.

我们将再次使用 ``jq`` 工具去追加 Org3 的配置定义 -- ``org3.json`` -- 到通道的应用组
字段，同时定义输出文件是 -- ``modified_config.json`` 。

.. code:: bash

  jq -s '.[0] * {"channel_group":{"groups":{"Application":{"groups": {"Org3MSP":.[1]}}}}}' config.json ./channel-artifacts/org3.json > modified_config.json

Now, within the CLI container we have two JSON files of interest -- ``config.json``
and ``modified_config.json``. The initial file contains only Org1 and Org2 material,
whereas "modified" file contains all three Orgs. At this point it's simply
a matter of re-encoding these two JSON files and calculating the delta.

现在，我们在 CLI 容器有两个重要的 JSON 文件 -- ``config.json`` 和 
``modified_config.json`` 。初始的文件包含 Org1 和 Org2 的材料，而 “modified” 文件包
含了总共 3 个组织。现在只需要将这 2 个 JSON 文件重新编码并计算出差异部分。

First, translate ``config.json`` back into a protobuf called ``config.pb``:

首先，将 ``config.json`` 文件倒回到 protobuf 格式，命名为 ``config.pb`` ：

.. code:: bash

  configtxlator proto_encode --input config.json --type common.Config --output config.pb

Next, encode ``modified_config.json`` to ``modified_config.pb``:

下一步，将 ``modified_config.json`` 编码成 ``modified_config.pb``:

.. code:: bash

  configtxlator proto_encode --input modified_config.json --type common.Config --output modified_config.pb

Now use ``configtxlator`` to calculate the delta between these two config
protobufs. This command will output a new protobuf binary named ``org3_update.pb``:

现在使用 ``configtxlator`` 去计算两个protobuf 配置的差异。这条命令会输出一个新的
protobuf 二进制文件，命名为 ``org3_update.pb`` 。

.. code:: bash

  configtxlator compute_update --channel_id $CHANNEL_NAME --original config.pb --updated modified_config.pb --output org3_update.pb

This new proto -- ``org3_update.pb`` -- contains the Org3 definitions and high
level pointers to the Org1 and Org2 material. We are able to forgo the extensive
MSP material and modification policy information for Org1 and Org2 because this
data is already present within the channel's genesis block. As such, we only need
the delta between the two configurations.

这个新的 proto 文件 -- ``org3_update.pb`` -- 包含了 Org3 的定义和指向 Org1 和 Org2 
材料的更高级别的指针。我们可以抛弃 Org1 和 Org2 相关的 MSP 材料和修改策略信息，因
为这些数据已经存在于通道的初始区块。因此，我们只需要两个配置的差异部分。

Before submitting the channel update, we need to perform a few final steps. First,
let's decode this object into editable JSON format and call it ``org3_update.json``:

在我们提交通道更新前，我们执行最后做几个步骤。首先，我们将这个对象解码成可编辑的 
JSON 格式，并命名为 ``org3_update.json`` 。

.. code:: bash

  configtxlator proto_decode --input org3_update.pb --type common.ConfigUpdate | jq . > org3_update.json

Now, we have a decoded update file -- ``org3_update.json`` -- that we need to wrap
in an envelope message. This step will give us back the header field that we stripped away
earlier. We'll name this file ``org3_update_in_envelope.json``:

现在，我们有了一个解码后的更新文件 -- ``org3_update.json`` -- 我们需要用信封消息来包装它。这
个步骤要把之前裁剪掉的头部信息还原回来。我们将命名这个新文件为 ``org3_update_in_envelope.json`` 。

.. code:: bash

  echo '{"payload":{"header":{"channel_header":{"channel_id":"mychannel", "type":2}},"data":{"config_update":'$(cat org3_update.json)'}}}' | jq . > org3_update_in_envelope.json

Using our properly formed JSON -- ``org3_update_in_envelope.json`` -- we will
leverage the ``configtxlator`` tool one last time and convert it into the
fully fledged protobuf format that Fabric requires. We'll name our final update
object ``org3_update_in_envelope.pb``:

使用我们格式化好的 JSON -- ``org3_update_in_envelope.json`` -- 我们最后一次使用
``configtxlator`` 工具将他转换为 Fabric 需要的完整独立的 protobuf 格式。我们将最
后的更新对象命名为 ``org3_update_in_envelope.pb`` 。

.. code:: bash

  configtxlator proto_encode --input org3_update_in_envelope.json --type common.Envelope --output org3_update_in_envelope.pb

Sign and Submit the Config Update - 签名并提交配置更新
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Almost done!

差不多大功告成了！

We now have a protobuf binary -- ``org3_update_in_envelope.pb`` -- within
our CLI container. However, we need signatures from the requisite Admin users
before the config can be written to the ledger. The modification policy (mod_policy)
for our channel Application group is set to the default of "MAJORITY", which means that
we need a majority of existing org admins to sign it. Because we have only two orgs --
Org1 and Org2 -- and the majority of two is two, we need both of them to sign. Without
both signatures, the ordering service will reject the transaction for failing to
fulfill the policy.

我们现在有一个 protobuf 二进制文件 -- ``org3_update_in_envelope.pb`` -- 在我们的 CLI 容
器内。但是，在配置写入到账本前，我们需要来自必要的 Admin 用户的签名。我们通道应用组的修
改策略（mod_policy）设置为默认值 “MAJORITY”，这意味着我们需要大多数已经存在的组织管理员
去签名这个更新。因为我们只有两个组织 -- Org1 和 Org2 -- 所以两个的大多数也还是两个，我们
需要它们都签名。没有这两个签名，排序服务会因为不满足策略而拒绝这个交易。

First, let's sign this update proto as the Org1 Admin. Remember that the CLI container
is bootstrapped with the Org1 MSP material, so we simply need to issue the
``peer channel signconfigtx`` command:

首先，让我们以 Org1 管理员来签名这个更新 proto 。因为 CLI 容器是以 Org1 MSP 材料启动的，
所以我们只需要简单地执行 ``peer channel signconfigtx`` 命令：

.. code:: bash

  peer channel signconfigtx -f org3_update_in_envelope.pb

The final step is to switch the CLI container's identity to reflect the Org2 Admin
user. We do this by exporting four environment variables specific to the Org2 MSP.

最后一步，我们将 CLI 容器的身份切换为 Org2 管理员。为此，我们通过导出和 Org2 MSP 相
关的 4 个环境变量。

.. note:: Switching between organizations to sign a config transaction (or to do anything
          else) is not reflective of a real-world Fabric operation. A single container
          would never be mounted with an entire network's crypto material. Rather, the
          config update would need to be securely passed out-of-band to an Org2
          Admin for inspection and approval.

          切换不同的组织身份为配置交易签名（或者其他事情）不能反映真实世界里 Fabric 的操作。
          一个单一容器不可能挂载了整个网络的加密材料。相反地，配置更新需要在网络外安全地递交
          给 Org2 管理员来审查和批准。

Export the Org2 environment variables:

导出 Org2 的环境变量：

.. code:: bash

  # you can issue all of these commands at once

  export CORE_PEER_LOCALMSPID="Org2MSP"

  export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tls/ca.crt

  export CORE_PEER_MSPCONFIGPATH=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org2.example.com/users/Admin@org2.example.com/msp

  export CORE_PEER_ADDRESS=peer0.org2.example.com:9051

Lastly, we will issue the ``peer channel update`` command. The Org2 Admin signature
will be attached to this call so there is no need to manually sign the protobuf a
second time:

最后，我们执行 ``peer channel update`` 命令。Org2 管理员在这个命令中会附带签名，因
此就没有必要对 protobuf 进行两次签名。

.. note:: The upcoming update call to the ordering service will undergo a series
          of systematic signature and policy checks. As such you may find it
          useful to stream and inspect the ordering node's logs. From another shell,
          issue a ``docker logs -f orderer.example.com`` command to display them.

          将要做的对排序服务的更新调用，会经历一系列的系统级签名和策略检查。你会发现
          通过检视排序节点的日志流会非常有用。在另外一个终端执行 
          ``docker logs -f orderer.example.com`` 命令就能展示它们了。

Send the update call:

发起更新调用：

.. code:: bash

  peer channel update -f org3_update_in_envelope.pb -c $CHANNEL_NAME -o orderer.example.com:7050 --tls --cafile $ORDERER_CA

You should see a message digest indication similar to the following if your
update has been submitted successfully:

如果你的更新提交成功，将会看到一个类似如下的摘要提示信息：

.. code:: bash

  2018-02-24 18:56:33.499 UTC [msp/identity] Sign -> DEBU 00f Sign: digest: 3207B24E40DE2FAB87A2E42BC004FEAA1E6FDCA42977CB78C64F05A88E556ABA

You will also see the submission of our configuration transaction:

你也会看到配置交易的提交：

.. code:: bash

  2018-02-24 18:56:33.499 UTC [channelCmd] update -> INFO 010 Successfully submitted channel update

The successful channel update call returns a new block -- block 5 -- to all of the
peers on the channel. If you remember, blocks 0-2 are the initial channel
configurations while blocks 3 and 4 are the instantiation and invocation of
the ``mycc`` chaincode. As such, block 5 serves as the most recent channel
configuration with Org3 now defined on the channel.

成功的通道更新调用会返回一个新的区块 --  区块 5 -- 给所有在这个通道上的节点。你是否
还记得，区块 0-2 是初始的通道配置，而区块 3 和 4 是链码 ``mycc`` 的实例化和调用。所
以，区块 5 就是带有 Org3 定义的最新的通道配置。

Inspect the logs for ``peer0.org1.example.com``:

查看 ``peer0.org1.example.com`` 的日志：

.. code:: bash

      docker logs -f peer0.org1.example.com

Follow the demonstrated process to fetch and decode the new config block if you wish to inspect
its contents.

如果你想查看新的配置区块的内容，可以跟着示范的过程获取和解码配置区块。

Configuring Leader Election - 配置领导节点选举
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. note:: This section is included as a general reference for understanding
          the leader election settings when adding organizations to a network
          after the initial channel configuration has completed. This sample
          defaults to dynamic leader election, which is set for all peers in the
          network in `peer-base.yaml`.

          引入这个章节作为通用参考，是为了理解在完成网络通道配置初始化之后，增加
          组织时，领导节点选举的设置。这个例子中，默认设置为动态领导选举，这是在 
          ``peer-base.yaml`` 文件中为网络中所有的节点设置的。

Newly joining peers are bootstrapped with the genesis block, which does not
contain information about the organization that is being added in the channel
configuration update. Therefore new peers are not able to utilize gossip as
they cannot verify blocks forwarded by other peers from their own organization
until they get the configuration transaction which added the organization to the
channel. Newly added peers must therefore have one of the following
configurations so that they receive blocks from the ordering service:

新加入的节点是根据初始区块启动的，初始区块是不包含通道配置更新中新加入的组织信息
的。因此新的节点无法利用 gossip 协议，因为它们无法验证从自己组织里其他节点发送过
来的区块，除非它们接收到将组织加入到通道的那个配置交易。新加入的节点必须有以下配
置之一才能从排序服务接收区块：

1. To utilize static leader mode, configure the peer to be an organization
leader:

1. 采用静态领导者模式，将节点配置为组织的领导者。

::

    CORE_PEER_GOSSIP_USELEADERELECTION=false
    CORE_PEER_GOSSIP_ORGLEADER=true


.. note:: This configuration must be the same for all new peers added to the
          channel.

          这个配置对于新加入到通道中的所有节点必须一致。

2. To utilize dynamic leader election, configure the peer to use leader
election:

2. 采用动态领导者选举，配置节点采用领导选举的方式：

::

    CORE_PEER_GOSSIP_USELEADERELECTION=true
    CORE_PEER_GOSSIP_ORGLEADER=false


.. note:: Because peers of the newly added organization won't be able to form
          membership view, this option will be similar to the static
          configuration, as each peer will start proclaiming itself to be a
          leader. However, once they get updated with the configuration
          transaction that adds the organization to the channel, there will be
          only one active leader for the organization. Therefore, it is
          recommended to leverage this option if you eventually want the
          organization's peers to utilize leader election.

          因为新加入组织的节点，无法生成成员关系视图，这个选项和静态配置类似，每
          个节点启动时宣称自己是领导者。但是，一旦它们更新到了将组织加入到通道的
          配置交易，组织中将只会有一个激活状态的领导者。因此，如果你想最终组织的
          节点采用领导选举，建议你采用这个配置。

Join Org3 to the Channel - 将 Org3 加入通道
~~~~~~~~~~~~~~~~~~~~~~~~

At this point, the channel configuration has been updated to include our new
organization -- ``Org3`` -- meaning that peers attached to it can now join ``mychannel``.

此时，通道的配置已经更新并包含了我们新的组织 -- ``Org3`` -- 意味者这个组织下的节点可以加入
到 ``mychannel`` 。

First, let's launch the containers for the Org3 peers and an Org3-specific CLI.

首先，让我们部署 Org3 节点容器和 Org3-specific CLI容器。

Open a new terminal and from ``first-network`` kick off the Org3 docker compose:

打开一个新的终端并从 ``first-network`` 目录启动 Org3 docker compose ：

.. code:: bash

  docker-compose -f docker-compose-org3.yaml up -d

This new compose file has been configured to bridge across our initial network,
so the two peers and the CLI container will be able to resolve with the existing
peers and ordering node. With the three new containers now running, exec into
the Org3-specific CLI container:

这个新的 compose 文件配置为桥接我们的初始网络，因此两个节点容器和 CLI 容器可以连
接到已经存在的节点和排序节点。当三个容器运行后，进入 Org3-specific CLI 容器：

.. code:: bash

  docker exec -it Org3cli bash

Just as we did with the initial CLI container, export the two key environment
variables: ``ORDERER_CA`` and ``CHANNEL_NAME``:

和我们之前初始化 CLI 容器一样，导出两个关键环境变量： ``ORDERER_CA`` 和 
``CHANNEL_NAME`` ：

.. code:: bash

  export ORDERER_CA=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem && export CHANNEL_NAME=mychannel

Check to make sure the variables have been properly set:

检查确保环境变量已经正确设置：

.. code:: bash

  echo $ORDERER_CA && echo $CHANNEL_NAME

Now let's send a call to the ordering service asking for the genesis block of
``mychannel``. The ordering service is able to verify the Org3 signature
attached to this call as a result of our successful channel update. If Org3
has not been successfully appended to the channel config, the ordering
service should reject this request.

现在，我们向排序服务发送一个获取 ``mychannel`` 初始区块的请求。如果通道更新成
功执行，排序服务会成功校验这个请求中 Org3 的签名。如果 Org3 没有成功地添加到通
道配置中，排序服务会拒绝这个请求。

.. note:: Again, you may find it useful to stream the ordering node's logs
          to reveal the sign/verify logic and policy checks.

          再次提醒，你会发现查看排序节点的签名和验签逻辑和策略检查的日志是
          很有用的。

Use the ``peer channel fetch`` command to retrieve this block:

使用 ``peer channel fetch`` 命令来获取这个区块：

.. code:: bash

  peer channel fetch 0 mychannel.block -o orderer.example.com:7050 -c $CHANNEL_NAME --tls --cafile $ORDERER_CA

Notice, that we are passing a ``0`` to indicate that we want the first block on
the channel's ledger (i.e. the genesis block). If we simply passed the
``peer channel fetch config`` command, then we would have received block 5 -- the
updated config with Org3 defined. However, we can't begin our ledger with a
downstream block -- we must start with block 0.

注意，我们传递了 ``0`` 去索引我们在这个通道账本上想要的区块（例如，初始区块）。如
果我们简单地执行 ``peer channel fetch config`` 命令，我们将会收到区块 5 -- 那个带
有 Org3 定义的更新后的配置。然而，我们的账本不能从一个下游的区块开始 -- 我们必须
从区块 0 开始。


Issue the ``peer channel join`` command and pass in the genesis block -- ``mychannel.block``:

执行 ``peer channel join`` 命令并指定初始区块 -- ``mychannel.block`` ：

.. code:: bash

  peer channel join -b mychannel.block

If you want to join the second peer for Org3, export the ``TLS`` and ``ADDRESS`` variables
and reissue the ``peer channel join command``:

如果你想将第二个节点加入到 Org3 中，导出 ``TLS`` 和 ``ADDRESS`` 变量，再重新执
行 ``peer channel join command`` 。

.. code:: bash

  export CORE_PEER_TLS_ROOTCERT_FILE=/opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org3.example.com/peers/peer1.org3.example.com/tls/ca.crt && export CORE_PEER_ADDRESS=peer1.org3.example.com:12051

  peer channel join -b mychannel.block

.. _upgrade-and-invoke:

Install, define, and invoke chaincode
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Once you have joined the channel, you can package and install a chaincode on a
peer of Org3. You then need to approve the chaincode definition as org3.
Because the chaincode definition has already been committed to the channel
you have joined, you can start using the chaincode after you approve the
definition.

.. note:: These instructions use the Fabric chaincode lifecycle introduced in
          the v2.0 Alpha release. If you would like to use the previous
          lifecycle to install and instantiate a chaincode, visit the v1.4
          version of the `Adding an org to a channel tutorial <https://hyperledger-fabric.readthedocs.io/en/release-1.4/channel_update_tutorial.html>`__.

The first step is to package the chaincode from the Org3 CLI:

.. code:: bash

    peer lifecycle chaincode package mycc.tar.gz --path github.com/hyperledger/fabric-samples/chaincode/abstore/go/ --lang golang --label mycc_1

This command will create a chaincode package named ``mycc.tar.gz``, which we can
use to install the chaincode on our peer. In this command, you need to provide a
chaincode package label as a description of the chaincode. Modify the command
accordingly if the channel is running a chaincode written in Java or Node.js.
Issue the following command to install the package on peer0 of Org3:

.. code:: bash

    # this command installs a chaincode package on your peer
    peer lifecycle chaincode install mycc.tar.gz

You can also modify the environment variables and reissue the command if you
want to install the chaincode on the second peer of Org3. Note that a second
installation is not mandated, as you only need to install chaincode on peers
that are going to serve as endorsers or otherwise interface with the ledger
(i.e. query only). Peers will still run the validation logic and serve as
committers without a running chaincode container.

The next step is to approve the chaincode definition of ``mycc`` as Org3. Org3
needs to approve the same definition that Org1 and Org2 approved and committed
to the channel. The chaincode definition also needs to include the chaincode
package identifier. You can find the package identifier by querying your peer:

.. code:: bash

    # this returns the details of the packages installed on your peers
    peer lifecycle chaincode queryinstalled

You should see output similar to the following:

.. code:: bash

      Get installed chaincodes on peer:
      Package ID: mycc_1:3a8c52d70c36313cfebbaf09d8616e7a6318ababa01c7cbe40603c373bcfe173, Label: mycc_1

We are going to need the package ID in a future command, so lets go ahead and
save it as an environment variable. Paste the package ID returned by the
`peer lifecycle chaincode queryinstalled` into the command below. The package ID
may not be the same for all users, so you need to complete this step using the
package ID returned from your console.

.. code:: bash

   # Save the package ID as an environment variable.

   CC_PACKAGE_ID=mycc_1:3a8c52d70c36313cfebbaf09d8616e7a6318ababa01c7cbe40603c373bcfe173

Use the following command to approve a definition of the  ``mycc`` chaincode
for Org3:

.. code:: bash

    # this approves a chaincode definition for your org
    # use the --package-id flag to provide the package identifier
    # use the --init-required flag to request the ``Init`` function be invoked to initialize the chaincode
    peer lifecycle chaincode approveformyorg --channelID $CHANNEL_NAME --name mycc --version 1.0 --init-required --package-id $CC_PACKAGE_ID --sequence 1 --tls true --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem --waitForEvent

You can use the ``peer lifecycle chaincode querycommitted`` command to check if
the chaincode definition you have approved has already been committed to the
channel.

.. code:: bash

    # use the --name flag to select the chaincode whose definition you want to query
    peer lifecycle chaincode querycommitted --channelID $CHANNEL_NAME --name mycc --cafile /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/ordererOrganizations/example.com/orderers/orderer.example.com/msp/tlscacerts/tlsca.example.com-cert.pem

A successful command will return information about the committed definition:

.. code:: bash

    Committed chaincode definition for chaincode 'mycc' on channel 'mychannel':
    Version: 1, Sequence: 1, Endorsement Plugin: escc, Validation Plugin: vscc

Since the chaincode definition has already been committed, you are ready to use
the ``mycc`` chaincode after you approve the definition. The chaincode definition
uses the default endorsement policy, which requires a majority of organizations
on the channel endorse a transaction. This implies that if an organization is
added to or removed from the channel, the endorsement policy is updated
automatically. We previously needed endorsements from Org1 and Org2 (2 out of 2).
Now we need endorsements from two organizations out of Org1, Org2, and Org3 (2
out of 3).

Query the chaincode to ensure that it has started. Note that you may need to
wait for the chaincode container to start.

.. code:: bash

    peer chaincode query -C $CHANNEL_NAME -n mycc -c '{"Args":["query","a"]}'

We should see a response of ``Query Result: 90``.

Now issue an invocation to move ``10`` from ``a`` to ``b``. In the command
below, we target a peer in Org1 and Org3 to collect a sufficient number of
endorsements.

.. code:: bash

    peer chaincode invoke -o orderer.example.com:7050  --tls $CORE_PEER_TLS_ENABLED --cafile $ORDERER_CA -C $CHANNEL_NAME -n mycc -c '{"Args":["invoke","a","b","10"]}' --peerAddresses peer0.org1.example.com:7051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tls/ca.crt --peerAddresses peer0.org3.example.com:11051 --tlsRootCertFiles /opt/gopath/src/github.com/hyperledger/fabric/peer/crypto/peerOrganizations/org3.example.com/peers/peer0.org3.example.com/tls/ca.crt

Query one final time:

最后查询一次：

.. code:: bash

    peer chaincode query -C $CHANNEL_NAME -n mycc -c '{"Args":["query","a"]}'

We should see a response of ``Query Result: 80``, accurately reflecting the
update of this chaincode's world state.

我们能看到一个 ``Query Result: 80`` 的响应，准确反映了链码的世界状态的更新。

Conclusion - 总结
~~~~~~~~~~

The channel configuration update process is indeed quite involved, but there is a
logical method to the various steps. The endgame is to form a delta transaction object
represented in protobuf binary format and then acquire the requisite number of admin
signatures such that the channel configuration update transaction fulfills the channel's
modification policy.

通道配置的更新过程是非常复杂的，但是仍然有一个诸多步骤对应的逻辑方法。终局就是为了构建
一个用 protobuf 二进制表达的差异化的交易对象，然后获取必要数量的管理员签名来满足通道的
修改策略。

The ``configtxlator`` and ``jq`` tools, along with the ever-growing ``peer channel``
commands, provide us with the functionality to accomplish this task.

``configtxlator`` 和 ``jq`` 工具，和不断使用的 ``peer channel`` 命令，为我们提供了完成
这个任务的基本功能。

.. Licensed under Creative Commons Attribution 4.0 International License
   https://creativecommons.org/licenses/by/4.0/
